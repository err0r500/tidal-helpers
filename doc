sine :: Fractional a => Pattern a
A sine wave.
d1 $ sound "bd*8" # pan sine


cosine :: Fractional a => Pattern a
A cosine wave, i.e. a sine shifted in time by a quarter of a cycle.
d1 $ sound "bd*8" # pan cosine # speed (sine + 0.5)


square :: Fractional a => Pattern a
A squarewave, starting at 0, then going up to 1 halfway through a cycle.
d1 $ sound "bd*8" # pan (cat [square, sine])


tri :: Fractional a => Pattern a
A triangle wave, starting at 0, then linearly rising to 1 halfway through a cycle, then down again.
d1 $ sound "bd*16" # speed (slow 2 $ range 0.5 2 tri)


saw :: Fractional a => Pattern a
A sawtooth wave starting at 0, then linearly rising to 1 over one cycle, then jumping back to 0.
d1 $ sound "bd*8" # pan (slow 2 saw)


isaw :: Fractional a => Pattern a
An inverted sawtooth, starting at 1, then linearly falling to 0 over one cycle, then jumping back to 1.
d1 $ sound "bd*8" # pan (slow 2 isaw)


rand :: Fractional a => Pattern a
An infinitely detailed stream of (pseudo-)random numbers. See[ the rand page for more details.
d1 $ sound "bd*8" # pan rand


irand :: Num a => Int -> Pattern a
A function from an integer (giving the maximum) to a stream of (pseudo-)random integer numbers. See[ the rand page for more details.
d1 $ sound "drum*8" # n (irand 8)


choose :: [a] -> Pattern a
The choose function emits a stream of randomly choosen values from the given list, as a continuous pattern.
d1 $ sound "drum ~ drum drum" # n (choose [0,2,3])
As with all continuous patterns, you have to be careful to give them structure; in this case choose gives you an infinitely detailed stream of random choices.


chooseBy :: Pattern Double -> [a] -> Pattern a
The chooseBy function is like choose but instead of selecting elements of the list randomly, it uses the given pattern to select elements.
chooseBy "0 0.25 0.5" ["a","b","c","d"]
will result in the pattern "a b c"


wchoose :: [(a, Double)] -> Pattern a
wchoose is similar to choose, but allows you to 'weight' the choices, so some are more likely to be chosen than others. The following is similar to the previous example, but the 2 is twice as likely to be chosen than the 0 or 3.
d1 $ sound "drum ~ drum drum" # n (wchoose [(0,0.25),(2,0.5),(3,0.25)])
Note: prior to version 1.0.0 of tidal, the weights had to add up to 1, but this is no longer the case.


wchooseBy :: Pattern Double -> [(a,Double)] -> Pattern a
The wchooseBy function is like wchoose but instead of selecting elements of the list randomly, it uses the given pattern to select elements.


perlin :: Pattern Double
perlin produces 1D Perlin (smooth) noise. It works like rand but smoothly moves between random values each cycle.
For example, you can smoothly and randomly change speed:
d1 $ sound "bd*32" # speed (perlin + 0.5)
The perlin function produces a new random value to move to every cycle. If you want a new random value to be generated more or less frequently, you can use fast or slow, respectively:
d1 $ sound "bd*32" # speed (fast 4 $ perlin + 0.5)
d1 $ sound "bd*32" # speed (slow 4 $ perlin + 0.5)


perlinWith :: Pattern Double -> Pattern Double
perlinWith allows you to specify a pattern as input to generate random values instead of using the default cycle count:
d1 $ s "arpy*32" # cutoff (perlinWith (saw * 4) * 2000)


perlin2 :: Pattern Double -> Pattern Double
perlin2 creates 2D noise by allowing you to specify a custom pattern as a second dimension (cycle number remains as the first dimension):
d1 $ s "bd*32" # speed (perlin2 (sine*4) + 1)


perlin2With :: Pattern Double -> Pattern Double -> Pattern Double
perlin2With is the same as perlinWith except allows you to provide two functions for 2D noise:
d1
 $ s "[arpy*32]"
 # lpf (range 60 5000 $ perlin2With (cosine*2) (sine*2))
 # lpq 0.3


silence :: Pattern a
silence is the empty pattern, it contains nothing, nada. It's still useful, though!
d1 $ sound "bd(3,8)" -- make a sound
d1 $ silence -- stop it again
d1 $ cat [sound "bd(3,8)", silence] -- silence every other pattern


accelerate :: Pattern Double -> ControlPattern
accelerate turns a number pattern into a control pattern that speeds up (or slows down) samples while they play.
d1 $ sound "jvbass*4" # accelerate "<0 1 -1 0.25 -0.5 2.1 -3>"


attack :: Pattern Double -> ControlPattern
attack turns a number pattern into a control pattern that changes the "fade in" time of a sample.
d1 $ s "[jvbass rave]/2" # attack "<0 0.1 0.2 0.3 0.5>"


bandf :: Pattern Double -> ControlPattern
bandf turns a number pattern into a control pattern that sets the center frequency of a band pass filter. In SuperDirt, this is in Hz (try a range between 0 and 10000). In classic dirt, it is from 0 to 1.
You can use bpf as a shortcut for bandf.
d1 $ s "drum*8" # bandf "100 1000 2000"


bandq :: Pattern Double -> ControlPattern
bandq turns a number pattern into a control pattern that sets the q-factor of the band-pass filter. Higher values (larger than 1) narrow the band-pass. Has the shorthand bpq.
You can use bpq as a shortcut for bandq.
d1 $ s "[drum cp]*2 [drum:1 hh*2]" # bandf "100 1000 2000" # bandq "<0.5 1 2>"


begin :: Pattern Double -> ControlPattern
begin turns a number pattern into a control pattern that changes the start position of a sample.
begin takes a pattern of numbers from 0 to 1. It skips the beginning of each sample, e.g. 0.25 to cut off the first quarter from each sample, 0.5 to cut off the first half, and so on:
d1 $ s "rave/2" # begin "<0 0.25 0.5>"


coarse :: Pattern Int -> ControlPattern
coarse turns a number pattern into a control pattern that lowers the sample rate of a sample. i.e. 1 for original 2 for half, 3 for a third and so on.
d1 $ s "bd*2 arpy*2 cp hh*3" # coarse "<4 8 16 24>"


crush :: Pattern Double -> ControlPattern
crush turns a number pattern into a control pattern that creates a bit-crushing effect.
Use values between 1 and 16, where 1 results in a drastic bit reduction, and 16 results in barely any reduction.
You can also use negative values for a slightly different effect.
d1 $ s "[bd cp] hh drum arpy*2" # crush "<16 4 2>"


cut :: Pattern Int -> ControlPattern
In the style of classic drum-machines, cut will stop a playing sample as soon as another sample with the same cutgroup is played.
An example would be an open hi-hat followed by a closed one, and stopping the open hi-hat from playing when a closed one starts:
d1 $ stack [
  sound "bd",
  sound "~ [~ [ho:2 hc/2]]" # cut "1"
  ]
This will mute the open hi-hat every second cycle when the closed one is played.
Using cut with negative values will only cut the same sample. This is useful to cut very long samples.
d1 $ sound "[bev, [ho:3](3,8)]" # cut "-1"
Using cut "0" is effectively no cutgroup.
You can also specify a pattern of cutgroups to mute a sample at different times:
d1 $ sound "bev(3,8)" # cut "[1 2 3]*2"


cutoff :: Pattern Double -> ControlPattern
cutoff turns a number pattern into a control pattern that sets the cutoff frequency of a low pass filter. In SuperDirt, this is in Hz (try a range between 0 and 10000). In classic dirt, it is from 0 to 1.
A shortcut for cutoff is lpf.
d1 $ s "drum*8" # cutoff "100 1000 2000"


delay :: Pattern Double -> ControlPattern
delay turns a number pattern into a control pattern that changes the level of the initial delay signal. A value of 1 means the first echo will be as loud as the original sound.
d1 $ s "[drum cp]*2 jvbass" # delay "[0 0.5]/2" # orbit 1
As delay is a global effect, you will want to use it in tandem with orbit (unless you're only running one pattern at a time).


delayfeedback :: Pattern Double -> ControlPattern
delayfeedback turns a number pattern into a control pattern that changes the feedback level of the delay effect. The delay function is required in order for the delayfeedback function to have any effect.
You can use delayfb as a shortcut for delayfeedback.
d1 $ s "drum jvbass [cp arpy] jvbass:1" # delayfeedback "[0.1 0.5 0.9]/6" # delay "0.5"


delaytime :: Pattern Double -> ControlPattern
delaytime turns a number pattern into a control pattern that changes the length of the delay effect. The delay function is required in order for delaytime to have any effect.
d1 $ s "drum*4 [drum:1 drum:2/2]" # delaytime "<0 0.01 0.1 0.2 0.5>" # delay "0.5"
Interesting results can be achieved when applying a continuous function to delaytime:
d1 $ s "drum*4 [drum:1 drum:2/2]" # delaytime (range 0.01 0.3 $ slow 4 sine) # delay "0.5"
For clock synced delay, specify the lock parameter as 1 otherwise delay defaults to unsynced. The below should fill the empty spaces in the pattern with a ghost hit evenly between the specified samples.
d1 $ s "bd sn" # delaytime 0.25 # delay "0.8" # lock 1
Changing the cycles per second and the delay will adjust itself.
setcps 0.91
d1 $ s "bd sn" # delaytime 0.25 # delay "0.8" # lock 1


end :: Pattern Double -> ControlPattern
end turns a number pattern into a control pattern that changes the playback end position of a sample.
end takes a pattern of numbers from 0 to 1. It controls the end point of each sample. e.g. 0.75 to only play 75% of each sample, 0.5 to only play 50%, and so on:
d1 $ s "rave/2" # end "<0 0.25 0.5>"


gain :: Pattern Double -> ControlPattern
gain turns a number pattern into a control pattern that specifies volume. Values less than 1 make the sound quieter. Values greater than 1 make the sound louder.
d1 $ gain "1 0.5 1.25" # sound "feel"
d1 $ sound "bd*16" # gain (slow 3 $ sine)


hcutoff :: Pattern Double -> ControlPattern
hcutoff turns a number pattern into a control pattern that sets the cutoff frequency of a high pass filter. In SuperDirt, this is in Hz (try a range between 0 and 10000). In classic dirt, it is from 0 to 1.
hpf is a shortcut for hcutoff.
d1 $ s "drum*8" # hcutoff "100 1000 2000 5000"


hpf :: Pattern Double -> ControlPattern
hpf turns a number pattern into a control pattern that sets the cutoff frequency of a high pass filter. In SuperDirt, this is in Hz (try a range between 0 and 10000). In classic dirt, it is from 0 to 1.
hpf is a shortcut for hcutoff.
d1 $ s "drum*8" # hpf "100 1000 2000 5000"


hpq :: Pattern Double -> ControlPattern
hpq turns a number pattern into a control pattern that sets the resonance of a high pass filter. Values range from 0 to 1.
hpq is a shortcut for hresonance.
d1 $ s "drum*8" # hpf "1000" # hpq "0 0.2 0.4 0.6"


hresonance :: Pattern Double -> ControlPattern
hresonance turns a number pattern into a control pattern that sets the resonance of a high pass filter. Values range from 0 to 1.
hpq is a shortcut for hresonance.
d1 $ s "drum*8" # hpf "1000" # hresonance "0 0.2 0.4 0.6"


leslie :: Pattern Double -> ControlPattern
leslie controls dry/wet. "lrate" is the modulation rate (typical vintage rates would be 6.7 for "fast", 0.7 for "slow"). "lsize" is the physical size of the cabinet in meters, this mostly affects the Doppler amount (pitch warble).
d1 $ s "supermandolin*8" # leslie 1 # lsize 2.8 # lrate 6.7


loop :: Pattern Double -> ControlPattern
loop turns a number pattern into a control pattern that changes the number of times a sample plays from its begin and end points. A negative value behaves the same as its positive counterpart. With fractional loop values, the final iteration will be incomplete - for example, a value of 2.3 loops thrice with the final loop playing 30% of the sample between its begin and end points.
d1 $ s "ho" # loop "2.2"
To alter the loop points, you can use begin and end.


lpf :: Pattern Double -> ControlPattern
lpf turns a number pattern into a control pattern that sets the cutoff frequency of a low pass filter. In SuperDirt, this is in Hz (try a range between 0 and 10000). In classic dirt, it is from 0 to 1.
lpf is a shortcut for cutoff.
d1 $ s "drum*8" # lpf "100 1000 2000"


lpq :: Pattern Double -> ControlPattern
lpq turns a number pattern into a control pattern that sets the resonance of a low pass filter. Values range from 0 to 1.
lpq is a shortcut for resonance.
d1 $ s "drum*8" # lpf "400" # lpq "0 0.2 0.4 0.6"


midichan :: Pattern Double -> ControlPattern
midichan turns a number pattern into a control pattern that controls what MIDI channel to play a MIDI pattern on.
midichan is indexed at zero, which means a value of "0" will play on MIDI channel 1, a value of "1" will play on MIDI channel 2, and so on.
d1 $ note "0 3 7 9" # s "midi" # midichan "5"
Observe that you can make a pattern to play on multiple MIDI channels:
d1 $ note "0 3 7 9" # s "midi" # midichan "5 1 0 3"


midicmd :: Pattern String -> ControlPattern
midicmd turns a string pattern into a control pattern that controls what type of MIDI pattern to play. i.e. a control-change pattern, a note pattern, etc.
The default value of midicmd is noteon, which plays a note pattern:
d1 $ note "0 3 7 9" # s "midi" # midicmd "noteon"
-- is the same as:
d1 $ note "0 3 7 9" # s "midi"
If you want to send a control-change pattern, you need to specify a value of "control":
d1 $ control "0 50 100 30" # ctlNum 1 # s "midi" # midicmd "control"
Other types of midicmd values include "program", "touch", "polytouch", and "bend".


midinote :: Pattern Double -> ControlPattern
midinote turns a number pattern into a control pattern that specifies the note on a MIDI keyboard to play, beginning at zero. This is different from note, which instead normalizes zero to Middle C. midinote only works when using SuperDirt MIDI patterns.
To play a low A0, which is MIDI note 21:
d1 $ s "midi" # midinote "21"
To play a C4, or "middle C":
d1 $ s "midi" # midinote "60"
midinote is very similar to note. The difference is that midinote is not normalized to Middle C. midinote "0" plays the absolute lowest note in MIDI, and note "0" plays Middle C.


n :: Pattern Int -> ControlPattern
n turns a number pattern into a control pattern that changes the sample being played in the specified sound folder on disk. The default value is 0, which plays the first sample in the sound folder. A value of 1 plays the next sample in the folder, a value of 2 plays the next, and so on:
d1 $ s "drum*4" # n "0"
d1 $ s "drum*4" # n "1"
d1 $ s "drum*4" # n "2 3"
d1 $ s "drum*4" # n "0 1 2 3"
A shorthand version of n is to use a colon followed by a number after a sound name:
d1 $ s "drum:0"
d1 $ s "drum:1"
d1 $ s "drum:0 drum:3 drum:2 drum:1*2"
You can of course combine sound patterns with patterns of n to easily create patterns with more complexity:
d1 $ s "drum [cp hh] odx*2 arpy*2" # n "[1 3 5 0 2]/2"
n is an index that starts at zero, so to play the 5th sample in a folder, you would use the number 4:
d1 $ s "drum" # n "4"


nudge :: Pattern Double -> ControlPattern
nudge turns a number pattern into a control pattern that changes the timing of a sample. Allows for nice things like swing feeling:
d1 $ stack [
  sound "bd bd/4",
  sound "hh(5,8)"
  ] # nudge "[0 0.04]*4"
Low values will give a more human feeling, high values might result in quite the contrary.
You can also use nudge to create continuous time stretches (although this might be better to do with cps):
d1 $ s "drum*8" # nudge (range 0 1 $ slow 8 sine)
You can also use nudge to fine-tune timing with other processes.


orbit :: Pattern Int -> ControlPattern
orbit is used to separate out audio channels. One use is to deal with global effects such as room and delay.
For example if you run both of the following patterns at the same time, the reverb will switch on and off, seemingly at random. This is because reverb is a global effect, is therefore shared by both patterns, and one is trying to turn it on, while the other is trying to switch it off.
d1 $ sound "feel*4" # room 0.9 # sz 0.9
d2 $ sound "bd*16" # room 0
The answer is to put them into different orbits:
d1 $ sound "feel*4" # room 0.9 # sz 0.9 # orbit 0
d2 $ sound "bd*16" # room 0 # orbit 1
Orbits can also be used for sending out separate audio outputs to external software, such as a DAW.
There are two orbits (0 and 1) available by default, but you can add more by Configuring SuperDirt.


pan :: Pattern Double -> ControlPattern
pan turns a number pattern (ranging from 0 to 1) into a control pattern that specifies the audio channel. In a 2-channel setup, a value of 0 pans the audio hard left and a value of 1 pans the audio hard right. The default value is 0.5, which produces full volume on both channels.
d1 $ sound "bd feel odx drum" # pan "0 1 0.25 0.75"
d1 $ sound "bd*16" # pan (slow 3 $ sine)


release :: Pattern Double -> ControlPattern
release turns a number pattern into a control pattern that changes the "fade out" time of a sample.
d1 $ s "jvbass*8" # release "<0.1 0.3 0.6>"


resonance :: Pattern Double -> ControlPattern
resonance turns a number pattern into a control pattern that sets the resonance of a low pass filter. Values range from 0 to 1.
lpq is a shortcut for resonance.
d1 $ s "drum*8" # cutoff "1000" # resonance "0 0.2 0.4 0.6"


room :: Pattern Double -> ControlPattern
room controls reverb. It turns a number pattern (ranging from 0 to 1) into a control pattern that controls how much of the audio is signal is sent into the reverb effect.
d1 $ sound "bd feel odx drum" # room "0 1 0.25 0.75" # size 0.5 # orbit 1
As room is a global effect, you will want to use it in tandem with orbit (unless you're only running one pattern at a time).
The size function controls the reverb size.


shape :: Pattern Double -> ControlPattern
shape produces wave shaping distortion, a pattern of numbers from 0 for no distortion up to 1 for loads of distortion. It can get very loud if you reach 1 - be careful!
d1 $ sound "feel*4" # shape "0 0.2 0.4"
d1 $ sound "bd*16" # shape (range 0 0.5 $ saw)


size :: Pattern Double -> ControlPattern
size controls reverb room decay time. It turns a number pattern (ranging from 0 to 1) into a control pattern that controls the room decay time of the reverb effect.
d1 $ sound "bd" # room "0.5" # size "<0.1 0.5 0.9>"
The room function controls the reverb effect amount.


sound :: Pattern String -> ControlPattern
sound turns a pattern of strings into a control pattern representing sounds - either sample sets or synth names. This function is required when using SuperDirt.
d1 $ sound "feel bd hh peri"
This function also has a shorthand alias called s:
d1 $ s "feel bd hh peri"


speed :: Pattern Double -> ControlPattern
speed turns a number pattern into a control pattern that sets the playback speed of a sample where 1 means normal speed. Can be used as a cheap way of changing pitch for samples. Negative numbers will cause the sample to be played backwards.
d1 $ s "numbers" # speed "1"
d1 $ s "numbers" # speed "2"
d1 $ s "numbers" # speed "0.5"
d1 $ s "numbers" # speed "-1"
d1 $ s "numbers" # speed "[1 1.5 0.75 -1.25]/4"
When using this method to alter sample pitch, there’s a convenience parameter up, which uses units of semitones instead of multiplicative values. For example,
d1 $ s "arpy*4" # up "0 4 7 0"
will play the “arpy” sample at the original speed, then up 4 semitones (a third), then up 7 semitones (a fifth), then once more at the original speed.
The behavior of speed can also be changed by the unit function.


squiz :: Pattern Double -> ControlPattern
squiz is a simplistic pitch-raising algorithm, reminiscent of some weird mixture of filter, ring-modulator and pitch-shifter.
Values range from 1 to infinity, and represent the pitch ratio - for example, a value of 2 raises the pitch by one octave.
d1 $ s "drum*8" # squiz "1 2 8 256"


vowel :: Pattern String -> ControlPattern
vowel turns a string pattern into a control pattern that creates a formant filter to produce vowel sounds on samples.
Use values a, e, i, o, and u to add the effect. The rest ~ character creates no effect:
d1 $ s "jvbass*4" # vowel "[a e ~ i o u]/8"


waveloss :: Pattern Double -> ControlPattern
waveloss divides an audio stream into tiny segments, using the signal's zero-crossings as segment boundaries, and discards a defined fraction of them. Values range from 0 to 100.
d1 $ s "drum*8" # waveloss "20 66.6 80 10"


sometimes :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a
sometimes is function, that applies another function to a pattern, around 50% of the time, at random. It takes two inputs, the function to be applied, and the pattern you are applying it to.
For example to distort half the events in a pattern:
d1 $ sometimes (# crush 2) $ n "0 1 [~ 2] 3" # sound "arpy"
sometimes has a number of variants, which apply the function with different likelihood.
function	likelihood
always	100%
almostAlways	90%
often	75%
sometimes	50%
rarely	25%
almostNever	10%
never	0%


sometimesBy :: Pattern Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
If you want to be specific, you can use sometimesBy and a number, for example
sometimesBy 0.93 (# speed 2)
to apply the speed control on average 93 times out of a hundred.


every :: Pattern Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
every is function, that allows you to apply another function conditionally. It takes three inputs, how often the function should be applied (e.g. 3 to apply it every 3 cycles), the function to be applied, and the pattern you are applying it to.
For example to reverse a pattern every three cycles (and for the other two play it normally):
d1 $ every 3 rev $ n "0 1 [~ 2] 3" # sound "arpy"
Note that if the function you're applying requires additional parameters itself (such as fast 2 to make a pattern twice as fast), then you'll need to wrap it in parenthesis, like so:
d1 $ every 3 (fast 2) $ n "0 1 [~ 2] 3" # sound "arpy"
Otherwise, the every function will think it is being passed too many parameters.


every' :: Int -> Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
every' is a generalisation of every, taking one additional argument. The additional argument allows you to offset the function you are applying.
For example, every' 3 0 (fast 2) will speed up the cycle on cycles 0,3,6,… whereas every' 3 1 (fast 2) will transform the pattern on cycles 1,4,7,…
With this in mind, setting the second argument of every' to 0 gives the equivalent every function. For example, every 3 is equivalent to every' 3 0.


fix :: (ControlPattern -> ControlPattern) -> ControlPattern -> ControlPattern -> ControlPattern
The fix function applies another function to matching events in a pattern of controls.
For example:
d1 $ slow 2 $ fix (# crush 3) (n "[1,4]") $ n "0 1 2 3 4 5 6" # sound "arpy"
The above only adds the crush control when the n control is set to either 1 or 4.
You can be quite specific, for example fix (hurry 2) (s "drum" # n "1") to apply the function hurry 2 to sample 1 of the drum sampleset, and leave the rest as they are.



