this file is a consolidation of the official tidalCycles documentation : https://tidalcycles.org/index.php/Userbase


type Time = Rational

## CORE

(<~) :: Pattern Time -> Pattern a -> Pattern a
<~ is an operator that shifts a pattern backward in time, by the given amount.
For example, to shift a pattern by a quarter of a cycle, every fourth cycle:
d1 $ every 4 (0.25 <~) $ sound ("arpy arpy:1 arpy:2 arpy:3")
Or to alternate between different shifts:
d1 $ "<0 0.5 0.125>" <~ sound ("arpy arpy:1 arpy:2 arpy:3")


(~>) :: Pattern Time -> Pattern a -> Pattern a
~> Is the same as above, but shifts a pattern forwards in time. For example:
d1 $ every 4 (0.25 ~>) $ sound ("bd ~ sn:1 [mt ht]")


(<>) :: Pattern a -> Pattern a -> Pattern a
<> is the same as overlay described above but in operator form. For example:
d1 $ sound ("bd sn:2" <> "cp*3")


append :: Pattern a -> Pattern a -> Pattern a
slowAppend :: Pattern a -> Pattern a -> Pattern a
append combines two patterns into a new pattern, where cycles alternate between the first and second pattern.
d1 $ append (sound "bd*2 sn") (sound "arpy jvbass*2")


cat :: [Pattern a] -> Pattern a
slowcat :: [Pattern a] -> Pattern a
cat concatenates a list of patterns into a new pattern; each pattern in the list will maintain its original duration.
d1 $ cat [sound "bd*2 sn", sound "arpy jvbass*2"]
d1 $ cat [sound "bd*2 sn", sound "arpy jvbass*2", sound "drum*2"]
d1 $ cat [sound "bd*2 sn", sound "jvbass*3", sound "drum*2", sound "ht mt"]


every :: Pattern Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
every allows you to apply another function conditionally. It takes three inputs, how often the function should be applied (e.g. 3 to apply it every 3 cycles), the function to be applied, and the pattern you are applying it to.
For example to reverse a pattern every three cycles (and for the other two play it normally):
d1 $ every 3 rev $ n "0 1 [~ 2] 3" # sound "arpy"
Note that if the function you're applying requires additional parameters itself (such as fast 2 to make a pattern twice as fast), then you'll need to wrap it in parenthesis, like so:
d1 $ every 3 (fast 2) $ n "0 1 [~ 2] 3" # sound "arpy"
Otherwise, the every function will think it is being passed too many parameters.


every' :: Int -> Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
every' is a generalisation of every, taking one additional argument. The additional argument allows you to offset the function you are applying.
For example, every' 3 0 (fast 2) will speed up the cycle on cycles 0,3,6,… whereas every' 3 1 (fast 2) will transform the pattern on cycles 1,4,7,…
With this in mind, setting the second argument of every' to 0 gives the equivalent every function. For example, every 3 is equivalent to every' 3 0.


fast :: Pattern Time -> Pattern a -> Pattern a
density :: Pattern Time -> Pattern a -> Pattern a
fast speeds up a pattern. For example, the following will play the sound pattern "bd sn kurt" twice as fast (i.e. so it repeats twice per cycle), and the vowel pattern three times as fast:
d1 $ sound (fast 2 "bd sn kurt")
   # fast 3 (vowel "a e o")
The first parameter can be patterned, for example to play the pattern at twice the speed for the first half of each cycle and then four times the speed for the second half:
d1 $ fast "2 4" $ sound "bd sn kurt cp"


fastAppend :: Pattern a -> Pattern a -> Pattern a
fastAppend works like append described above, but each pair of cycles from the two patterns are squashed to fit a single cycle.
d1 $ fastAppend (sound "bd*2 sn") (sound "arpy jvbass*2")


fastcat :: [Pattern a] -> Pattern a
fastcat works like cat above, but squashes all the patterns to fit a single cycle. Examples:
d1 $ fastcat [sound "bd*2 sn", sound "arpy jvbass*2"]
d1 $ fastcat [sound "bd*2 sn", sound "arpy jvbass*2", sound "drum*2"]
d1 $ fastcat [sound "bd*2 sn", sound "jvbass*3", sound "drum*2", sound "ht mt"]


foldEvery :: [Int] -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
foldEvery transforms a pattern with a function, once per any of the given number of cycles. If a particular cycle is the start of more than one of the given cycle periods, then it it applied more than once. It is similar to chaining multiple every functions together.
d1 $ foldEvery [3, 4, 5] (fast 2) $ sound "bd sn kurt"
this is equal to:
d1 $ every 3 (fast 2) $ every 4 (fast 2) $ every 5 (fast 2) $ sound "bd sn kurt"


isaw :: Fractional a => Pattern a
An inverted sawtooth, starting at 1, then linearly falling to 0 over one cycle, then jumping back to 1.
d1 $ sound "bd*8" # pan (slow 2 isaw)


overlay :: Pattern a -> Pattern a -> Pattern a
The overlay function is similar to cat described above, but combines two patterns, rather than a list of patterns. For example:
d1 $ sound (overlay "bd sn:2" "cp*3")
...is the same as...
d1 $ sound "[bd sn:2, cp*3]"


repeatCycles :: Int -> Pattern a -> Pattern
repeatCycles is function that repeats each cycle of a given pattern a given number of times.. It takes two inputs, the number of repeats, and the pattern you are transforming.
For example, to repeat each random cycle of notes three times:
d1 $ repeatCycles 3 $ sound "arpy(5,8)" # n (irand 8)


rev :: Pattern a -> Pattern a
rev returns a 'reversed' version of the given pattern.
For example rev "1 [~ 2] ~ 3" is equivalent to rev "3 ~ [2 ~] 1".
Note that rev reverses on a cycle-by-cycle basis. This means that rev (slow 2 "1 2 3 4") would actually result in (slow 2 "2 1 4 3"). This is because the slow 2 makes the repeating pattern last two cycles, each of which is reversed independently.
In practice rev is generally used with conditionals, for example with every:
d1 $ every 3 rev $ n "0 1 [~ 2] 3" # sound "arpy"
or jux:
d1 $ jux rev $ n (iter 4 "0 1 [~ 2] 3") # sound "arpy"


run :: (Num a, Enum a) => Pattern a -> Pattern a
The run function generates a pattern representing a cycle of numbers from 0 to n-1 inclusive. Notably used to ‘run’ through a folder of samples in order:
d1 $ n (run 8) # sound "amencutup"
The first parameter to run can be given as a pattern:
d1 $ n (run "<4 8 4 6>") # sound "amencutup"


saw :: Fractional a => Pattern a
A sawtooth wave starting at 0, then linearly rising to 1 over one cycle, then jumping back to 0.
d1 $ sound "bd*8" # pan (slow 2 saw)


scan :: (Num a, Enum a) => Pattern a -> Pattern a
scan is similar to run, but starts at 1 for the first cycle, adding an additional number each cycle until it reaches n
d1 $ n (scan 8) # sound "amencutup"


silence :: Pattern a
silence is the empty pattern, it contains nothing, nada. It's still useful, though!
d1 $ sound "bd(3,8)" -- make a sound
d1 $ silence -- stop it again
d1 $ cat [sound "bd(3,8)", silence] -- silence every other pattern


sine :: Fractional a => Pattern a
A sine wave.
d1 $ sound "bd*8" # pan sine


slow :: Pattern Time -> Pattern a -> Pattern a
slow slows down a pattern. For example, the following will play the sound pattern "bd sn kurt" twice as slow (i.e. so it repeats once every two cycles), and the vowel pattern three times as slow:
d1 $ sound (slow 2 "bd sn kurt") # slow 3 (vowel "a e o")


square :: Fractional a => Pattern a
A squarewave, starting at 0, then going up to 1 halfway through a cycle.
d1 $ sound "bd*8" # pan (cat [square, sine])


stack :: [Pattern a] -> Pattern a
stack takes a list of patterns and combines them into a new pattern by layering them up - effectively playing all of the patterns in the list simultaneously.
d1 $ stack [ 
  sound "bd bd*2", 
  sound "hh*2 [sn cp] cp future*4", 
  sound "arpy" +| n "0 .. 15"
]
This is particularly useful if you want to apply a function or synth control pattern to multiple patterns at once:
d1 $ whenmod 5 3 (striate 3) $ stack [ 
  sound "bd bd*2", 
  sound "hh*2 [sn cp] cp future*4", 
  sound "arpy" +| n "0 .. 15"
] # speed "[[1 0.8], [1.5 2]*2]/3"


tri :: Fractional a => Pattern a
A triangle wave, starting at 0, then linearly rising to 1 halfway through a cycle, then down again.
d1 $ sound "bd*16" # speed (slow 2 $ range 0.5 2 tri)


when :: (Int -> Bool) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
Only when the given test function returns True the given pattern transformation is applied. The test function will be called with the current cycle as a number.
d1 $ when ((elem '4').show) (striate 4) $ sound "hh hc"
The above will only apply striate 4 to the pattern if the current cycle number contains the number 4. So the fourth cycle will be striated and the fourteenth and so on. Expect lots of striates after cycle number 399.


zoom :: (Time, Time) -> Pattern a -> Pattern a
Plays a portion of a pattern, specified by the beginning and end of a time span (known as an 'arc'). The new resulting pattern is played over the time period of the original pattern:
d1 $ zoom (0.25, 0.75) $ sound "bd*2 hh*3 [sn bd]*2 drum"
In the pattern above, zoom is used with an arc from 25% to 75%. It is equivalent to this pattern:
d1 $ sound "hh*3 [sn bd]*2"
Here’s an example of it being used with a conditional:
d1 $ every 4 (zoom (0.25, 0.75)) $ sound "bd*2 hh*3 [sn bd]*2 drum"



## CONTROL


accelerate :: Pattern Double -> ControlPattern
accelerate turns a number pattern into a control pattern that speeds up (or slows down) samples while they play.
d1 $ sound "jvbass*4" # accelerate "<0 1 -1 0.25 -0.5 2.1 -3>"


anticipate :: Time -> [ControlPattern] -> ControlPattern
Queue up a pattern to be triggered (or dropped) in at the specified number of cycles
d1 $ sound "jvbass(3,8)"
anticipate 4 $ sound "bd sn" # delay "0.5" # room "0.3"


attack :: Pattern Double -> ControlPattern
attack turns a number pattern into a control pattern that changes the "fade in" time of a sample.
d1 $ s "[jvbass rave]/2" # attack "<0 0.1 0.2 0.3 0.5>"


bandf :: Pattern Double -> ControlPattern
bandf turns a number pattern into a control pattern that sets the center frequency of a band pass filter. In SuperDirt, this is in Hz (try a range between 0 and 10000). In classic dirt, it is from 0 to 1.
You can use bpf as a shortcut for bandf.
d1 $ s "drum*8" # bandf "100 1000 2000"


bandq :: Pattern Double -> ControlPattern
bandq turns a number pattern into a control pattern that sets the q-factor of the band-pass filter. Higher values (larger than 1) narrow the band-pass. Has the shorthand bpq.
You can use bpq as a shortcut for bandq.
d1 $ s "[drum cp]*2 [drum:1 hh*2]" # bandf "100 1000 2000" # bandq "<0.5 1 2>"


begin :: Pattern Double -> ControlPattern
begin turns a number pattern into a control pattern that changes the start position of a sample.
begin takes a pattern of numbers from 0 to 1. It skips the beginning of each sample, e.g. 0.25 to cut off the first quarter from each sample, 0.5 to cut off the first half, and so on:
d1 $ s "rave/2" # begin "<0 0.25 0.5>"


clutch :: Time -> [Pattern a] -> Pattern a
clutch degrades the current pattern while undegrading the next.
This is like xfade but not by gain of samples but by randomly removing events from the current pattern and slowly adding back in missing events from the next one.
d1 $ sound "bd(3,8)"
clutch 1 $ sound "[hh*4, odx(3,8)]"
clutch takes two cycles for the transition, essentially this is clutchIn 2.


chop :: Pattern Int -> ControlPattern -> ControlPattern
chop cuts each sample into the given number of parts, allowing you to explore a technique known as 'granular synthesis'. It turns a pattern of samples into a pattern of parts of samples. For example:
d1 $ chop 16 $ sound "arpy ~ feel*2 newnotes"
In the above, each sample is chopped into 16 bits, resulting in 64 (16*4) events. You can pattern that first parameter:
d1 $ chop "<16 128 32>" $ sound "arpy ~ feel*2 newnotes"
You end up with a pattern of the chopped up bits of samples. You'll already be able to hear this more clearly if you for example reverse the pattern, as you'll reverse the order of the sample parts:
d1 $ slow 2 $ rev $ chop 16 $ sound "breaks125"
Lets try that reverse in just one speaker:
d1 $ slow 2 $ jux rev $ chop 16 $ sound "breaks125"
Different values of chop can yield very different results, depending on the samples used:
d1 $ chop 16 $ sound (samples "arpy*8" (run 16))
d1 $ chop 32 $ sound (samples "arpy*8" (run 16))
d1 $ chop 256 $ sound "bd*4 [sn cp] [hh future]*2 [cp feel]"
You can also use chop (or (striate)[#striate]) with very long samples, to cut it into short chunks and pattern those chunks. The following cuts a sample into 32 parts, and plays it over 8 cycles:
d1 $ loopAt 8 $ chop 32 $ sound "bev"
The loopAt takes care of changing the speed of sample playback so that the sample fits in the given number of cycles perfectly. As a result, in the above the granules line up perfectly, so you can’t really hear that the sample has been cut into bits. Again, this becomes more apparent when you do further manipulations of the pattern, for example rev to reverse the order of the cut up bits:
d1 $ loopAt 8 $ rev $ chop 32 $ sound "bev"


coarse :: Pattern Int -> ControlPattern
coarse turns a number pattern into a control pattern that lowers the sample rate of a sample. i.e. 1 for original 2 for half, 3 for a third and so on.
d1 $ s "bd*2 arpy*2 cp hh*3" # coarse "<4 8 16 24>"


crush :: Pattern Double -> ControlPattern
crush turns a number pattern into a control pattern that creates a bit-crushing effect.
Use values between 1 and 16, where 1 results in a drastic bit reduction, and 16 results in barely any reduction.
You can also use negative values for a slightly different effect.
d1 $ s "[bd cp] hh drum arpy*2" # crush "<16 4 2>"


cut :: Pattern Int -> ControlPattern
In the style of classic drum-machines, cut will stop a playing sample as soon as another sample with the same cutgroup is played.
An example would be an open hi-hat followed by a closed one, and stopping the open hi-hat from playing when a closed one starts:
d1 $ stack [
  sound "bd",
  sound "~ [~ [ho:2 hc/2]]" # cut "1"
  ]
This will mute the open hi-hat every second cycle when the closed one is played.
Using cut with negative values will only cut the same sample. This is useful to cut very long samples.
d1 $ sound "[bev, [ho:3](3,8)]" # cut "-1"
Using cut "0" is effectively no cutgroup.
You can also specify a pattern of cutgroups to mute a sample at different times:
d1 $ sound "bev(3,8)" # cut "[1 2 3]*2"


cutoff :: Pattern Double -> ControlPattern
cutoff turns a number pattern into a control pattern that sets the cutoff frequency of a low pass filter. In SuperDirt, this is in Hz (try a range between 0 and 10000). In classic dirt, it is from 0 to 1.
A shortcut for cutoff is lpf.
d1 $ s "drum*8" # cutoff "100 1000 2000"


delay :: Pattern Double -> ControlPattern
delay turns a number pattern into a control pattern that changes the level of the initial delay signal. A value of 1 means the first echo will be as loud as the original sound.
d1 $ s "[drum cp]*2 jvbass" # delay "[0 0.5]/2" # orbit 1
As delay is a global effect, you will want to use it in tandem with orbit (unless you're only running one pattern at a time).


delayfeedback :: Pattern Double -> ControlPattern
delayfeedback turns a number pattern into a control pattern that changes the feedback level of the delay effect. The delay function is required in order for the delayfeedback function to have any effect.
You can use delayfb as a shortcut for delayfeedback.
d1 $ s "drum jvbass [cp arpy] jvbass:1" # delayfeedback "[0.1 0.5 0.9]/6" # delay "0.5"


delaytime :: Pattern Double -> ControlPattern
delaytime turns a number pattern into a control pattern that changes the length of the delay effect. The delay function is required in order for delaytime to have any effect.
d1 $ s "drum*4 [drum:1 drum:2/2]" # delaytime "<0 0.01 0.1 0.2 0.5>" # delay "0.5"
Interesting results can be achieved when applying a continuous function to delaytime:
d1 $ s "drum*4 [drum:1 drum:2/2]" # delaytime (range 0.01 0.3 $ slow 4 sine) # delay "0.5"
For clock synced delay, specify the lock parameter as 1 otherwise delay defaults to unsynced. The below should fill the empty spaces in the pattern with a ghost hit evenly between the specified samples.
d1 $ s "bd sn" # delaytime 0.25 # delay "0.8" # lock 1
Changing the cycles per second and the delay will adjust itself.
setcps 0.91
d1 $ s "bd sn" # delaytime 0.25 # delay "0.8" # lock 1


end :: Pattern Double -> ControlPattern
end turns a number pattern into a control pattern that changes the playback end position of a sample.
end takes a pattern of numbers from 0 to 1. It controls the end point of each sample. e.g. 0.75 to only play 75% of each sample, 0.5 to only play 50%, and so on:
d1 $ s "rave/2" # end "<0 0.25 0.5>"


gain :: Pattern Double -> ControlPattern
gain turns a number pattern into a control pattern that specifies volume. Values less than 1 make the sound quieter. Values greater than 1 make the sound louder.
d1 $ gain "1 0.5 1.25" # sound "feel"
d1 $ sound "bd*16" # gain (slow 3 $ sine)


gap :: Pattern Int -> ControlPattern -> ControlPattern
gap is similar to chop in that it granulates every sample in place as it is played, but every other grain is silent. Use an integer value to specify how many granules each sample is chopped into:
d1 $ gap 8 $ sound "jvbass"
d1 $ gap 16 $ sound "[jvbass drum:4]"
You can also provide a pattern here:
d1 $ gap "<32 16 8 4>" $ sound "rave"


hcutoff :: Pattern Double -> ControlPattern
hcutoff turns a number pattern into a control pattern that sets the cutoff frequency of a high pass filter. In SuperDirt, this is in Hz (try a range between 0 and 10000). In classic dirt, it is from 0 to 1.
hpf is a shortcut for hcutoff.
d1 $ s "drum*8" # hcutoff "100 1000 2000 5000"


hpf :: Pattern Double -> ControlPattern
hpf turns a number pattern into a control pattern that sets the cutoff frequency of a high pass filter. In SuperDirt, this is in Hz (try a range between 0 and 10000). In classic dirt, it is from 0 to 1.
hpf is a shortcut for hcutoff.
d1 $ s "drum*8" # hpf "100 1000 2000 5000"


hpq :: Pattern Double -> ControlPattern
hpq turns a number pattern into a control pattern that sets the resonance of a high pass filter. Values range from 0 to 1.
hpq is a shortcut for hresonance.
d1 $ s "drum*8" # hpf "1000" # hpq "0 0.2 0.4 0.6"


hresonance :: Pattern Double -> ControlPattern
hresonance turns a number pattern into a control pattern that sets the resonance of a high pass filter. Values range from 0 to 1.
hpq is a shortcut for hresonance.
d1 $ s "drum*8" # hpf "1000" # hresonance "0 0.2 0.4 0.6"


jump :: Show a => a -> ControlPattern -> IO ()
jump is essentially the no transition-transition. It jumps directly into the given pattern. The variants jumpIn, jumpIn' and jumpMod provide more useful capabilities.
d1 $ sound "hh*4"
then both of the following lines will have the same effect when evaluated:
d1 $ sound "hh*8"
jump 1 $ sound "hh*8" --`1` to change the pattern in `d1`


jumpIn :: Show a => a -> Int -> ControlPattern -> IO () 
jumpIn' :: Show a => a -> Int -> ControlPattern -> IO () 
jumpIn' takes the identifier of the ControlPattern track and an integer cycleCount. It will jump at cycle boundary into the given pattern after cycleCount cycles have completed.
d1 $ sound "hh*4"
d2 $ sound "bd" --have a beat on the 1 for orientation
Then the subdivision on the hi-hat will increase 2 cycles after evaluation of the next line:
jumpIn' 1 2 $ sound "hh*8" --`1` because `d1`
with jumpIn' : The transition will align with the beat on cycle boundary.
with jumpIn : The transition will NOT align with the beat on cycle boundary.
with jumpMod : The transition will align with one of the next 2 bd onsets.


leslie :: Pattern Double -> ControlPattern
leslie controls dry/wet. "lrate" is the modulation rate (typical vintage rates would be 6.7 for "fast", 0.7 for "slow"). "lsize" is the physical size of the cabinet in meters, this mostly affects the Doppler amount (pitch warble).
d1 $ s "supermandolin*8" # leslie 1 # lsize 2.8 # lrate 6.7


loop :: Pattern Double -> ControlPattern
loop turns a number pattern into a control pattern that changes the number of times a sample plays from its begin and end points. A negative value behaves the same as its positive counterpart. With fractional loop values, the final iteration will be incomplete - for example, a value of 2.3 loops thrice with the final loop playing 30% of the sample between its begin and end points.
d1 $ s "ho" # loop "2.2"
To alter the loop points, you can use begin and end.


lpf :: Pattern Double -> ControlPattern
lpf turns a number pattern into a control pattern that sets the cutoff frequency of a low pass filter. In SuperDirt, this is in Hz (try a range between 0 and 10000). In classic dirt, it is from 0 to 1.
lpf is a shortcut for cutoff.
d1 $ s "drum*8" # lpf "100 1000 2000"


lpq :: Pattern Double -> ControlPattern
lpq turns a number pattern into a control pattern that sets the resonance of a low pass filter. Values range from 0 to 1.
lpq is a shortcut for resonance.
d1 $ s "drum*8" # lpf "400" # lpq "0 0.2 0.4 0.6"


midichan :: Pattern Double -> ControlPattern
midichan turns a number pattern into a control pattern that controls what MIDI channel to play a MIDI pattern on.
midichan is indexed at zero, which means a value of "0" will play on MIDI channel 1, a value of "1" will play on MIDI channel 2, and so on.
d1 $ note "0 3 7 9" # s "midi" # midichan "5"
Observe that you can make a pattern to play on multiple MIDI channels:
d1 $ note "0 3 7 9" # s "midi" # midichan "5 1 0 3"


midicmd :: Pattern String -> ControlPattern
midicmd turns a string pattern into a control pattern that controls what type of MIDI pattern to play. i.e. a control-change pattern, a note pattern, etc.
The default value of midicmd is noteon, which plays a note pattern:
d1 $ note "0 3 7 9" # s "midi" # midicmd "noteon"
-- is the same as:
d1 $ note "0 3 7 9" # s "midi"
If you want to send a control-change pattern, you need to specify a value of "control":
d1 $ control "0 50 100 30" # ctlNum 1 # s "midi" # midicmd "control"
Other types of midicmd values include "program", "touch", "polytouch", and "bend".


midinote :: Pattern Double -> ControlPattern
midinote turns a number pattern into a control pattern that specifies the note on a MIDI keyboard to play, beginning at zero. This is different from note, which instead normalizes zero to Middle C. midinote only works when using SuperDirt MIDI patterns.
To play a low A0, which is MIDI note 21:
d1 $ s "midi" # midinote "21"
To play a C4, or "middle C":
d1 $ s "midi" # midinote "60"
midinote is very similar to note. The difference is that midinote is not normalized to Middle C. midinote "0" plays the absolute lowest note in MIDI, and note "0" plays Middle C.


n :: Pattern Int -> ControlPattern
n turns a number pattern into a control pattern that changes the sample being played in the specified sound folder on disk. The default value is 0, which plays the first sample in the sound folder. A value of 1 plays the next sample in the folder, a value of 2 plays the next, and so on:
d1 $ s "drum*4" # n "0"
d1 $ s "drum*4" # n "1"
d1 $ s "drum*4" # n "2 3"
d1 $ s "drum*4" # n "0 1 2 3"
A shorthand version of n is to use a colon followed by a number after a sound name:
d1 $ s "drum:0"
d1 $ s "drum:1"
d1 $ s "drum:0 drum:3 drum:2 drum:1*2"
You can of course combine sound patterns with patterns of n to easily create patterns with more complexity:
d1 $ s "drum [cp hh] odx*2 arpy*2" # n "[1 3 5 0 2]/2"
n is an index that starts at zero, so to play the 5th sample in a folder, you would use the number 4:
d1 $ s "drum" # n "4"


nudge :: Pattern Double -> ControlPattern
nudge turns a number pattern into a control pattern that changes the timing of a sample. Allows for nice things like swing feeling:
d1 $ stack [
  sound "bd bd/4",
  sound "hh(5,8)"
  ] # nudge "[0 0.04]*4"
Low values will give a more human feeling, high values might result in quite the contrary.
You can also use nudge to create continuous time stretches (although this might be better to do with cps):
d1 $ s "drum*8" # nudge (range 0 1 $ slow 8 sine)
You can also use nudge to fine-tune timing with other processes.


orbit :: Pattern Int -> ControlPattern
orbit is used to separate out audio channels. One use is to deal with global effects such as room and delay.
For example if you run both of the following patterns at the same time, the reverb will switch on and off, seemingly at random. This is because reverb is a global effect, is therefore shared by both patterns, and one is trying to turn it on, while the other is trying to switch it off.
d1 $ sound "feel*4" # room 0.9 # sz 0.9
d2 $ sound "bd*16" # room 0
The answer is to put them into different orbits:
d1 $ sound "feel*4" # room 0.9 # sz 0.9 # orbit 0
d2 $ sound "bd*16" # room 0 # orbit 1
Orbits can also be used for sending out separate audio outputs to external software, such as a DAW.
There are two orbits (0 and 1) available by default, but you can add more by Configuring SuperDirt.


pan :: Pattern Double -> ControlPattern
pan turns a number pattern (ranging from 0 to 1) into a control pattern that specifies the audio channel. In a 2-channel setup, a value of 0 pans the audio hard left and a value of 1 pans the audio hard right. The default value is 0.5, which produces full volume on both channels.
d1 $ sound "bd feel odx drum" # pan "0 1 0.25 0.75"
d1 $ sound "bd*16" # pan (slow 3 $ sine)


release :: Pattern Double -> ControlPattern
release turns a number pattern into a control pattern that changes the "fade out" time of a sample.
d1 $ s "jvbass*8" # release "<0.1 0.3 0.6>"


resonance :: Pattern Double -> ControlPattern
resonance turns a number pattern into a control pattern that sets the resonance of a low pass filter. Values range from 0 to 1.
lpq is a shortcut for resonance.
d1 $ s "drum*8" # cutoff "1000" # resonance "0 0.2 0.4 0.6"


room :: Pattern Double -> ControlPattern
room controls reverb. It turns a number pattern (ranging from 0 to 1) into a control pattern that controls how much of the audio is signal is sent into the reverb effect.
d1 $ sound "bd feel odx drum" # room "0 1 0.25 0.75" # size 0.5 # orbit 1
As room is a global effect, you will want to use it in tandem with orbit (unless you're only running one pattern at a time).
The size function controls the reverb size.


shape :: Pattern Double -> ControlPattern
shape produces wave shaping distortion, a pattern of numbers from 0 for no distortion up to 1 for loads of distortion. It can get very loud if you reach 1 - be careful!
d1 $ sound "feel*4" # shape "0 0.2 0.4"
d1 $ sound "bd*16" # shape (range 0 0.5 $ saw)


size :: Pattern Double -> ControlPattern
size controls reverb room decay time. It turns a number pattern (ranging from 0 to 1) into a control pattern that controls the room decay time of the reverb effect.
d1 $ sound "bd" # room "0.5" # size "<0.1 0.5 0.9>"
The room function controls the reverb effect amount.


slice :: Pattern Int -> Pattern Int -> ControlPattern -> ControlPattern
slice is similar to chop and striate, in that it's used to slice samples up into bits. The difference is that it allows you to rearrange those bits as a pattern.
d1 $ slice 8 "7 6 5 4 3 2 1 0" $ sound "breaks165"
  # legato 1
The above slices the sample into eight bits, and then plays them backwards, equivalent of applying rev $ chop 8. Here's a more complex example:
d1 $ slice 8 "[<0*8 0*2> 3*4 2 4] [4 .. 7]" $ sound "breaks165"
  # legato 1
See also bite, which is similar but slices up patterns, rather than samples.
Note that the order of the first two parameters changed since tidal version 1.0.0
An extended use of slice


sound :: Pattern String -> ControlPattern
sound turns a pattern of strings into a control pattern representing sounds - either sample sets or synth names. This function is required when using SuperDirt.
d1 $ sound "feel bd hh peri"
This function also has a shorthand alias called s:
d1 $ s "feel bd hh peri"


speed :: Pattern Double -> ControlPattern
speed turns a number pattern into a control pattern that sets the playback speed of a sample where 1 means normal speed. Can be used as a cheap way of changing pitch for samples. Negative numbers will cause the sample to be played backwards.
d1 $ s "numbers" # speed "1"
d1 $ s "numbers" # speed "2"
d1 $ s "numbers" # speed "0.5"
d1 $ s "numbers" # speed "-1"
d1 $ s "numbers" # speed "[1 1.5 0.75 -1.25]/4"
When using this method to alter sample pitch, there’s a convenience parameter up, which uses units of semitones instead of multiplicative values. For example,
d1 $ s "arpy*4" # up "0 4 7 0"
will play the “arpy” sample at the original speed, then up 4 semitones (a third), then up 7 semitones (a fifth), then once more at the original speed.
The behavior of speed can also be changed by the unit function.


splice :: Int -> Pattern Int -> ControlPattern -> ControlPattern
splice is similar to slice, but the slices are automatically pitched up or down to fit their 'slot'.
d1 $ splice 8 "[<0*8 0*2> 3*4 2 4] [4 .. 7]" $ sound "breaks165"


spin :: Pattern Int -> ControlPattern -> ControlPattern
spin will play the given number of copies of the given control pattern at once. For n copies, each successive copy will be offset in time by an additional 1/n of a cycle, and also panned in space by an additional n1/n</source>. This function works particularly well on multichannel systems.
d1 $ slow 3 $ spin 4 $ sound "drum*3 tabla:4 [arpy:2 ~ arpy] [can:2 can:3]"


squiz :: Pattern Double -> ControlPattern
squiz is a simplistic pitch-raising algorithm, reminiscent of some weird mixture of filter, ring-modulator and pitch-shifter.
Values range from 1 to infinity, and represent the pitch ratio - for example, a value of 2 raises the pitch by one octave.
d1 $ s "drum*8" # squiz "1 2 8 256"


striate :: Pattern Int -> ControlPattern -> ControlPattern
striate is a kind of granulator, cutting samples into bits in a similar to chop, but the resulting bits are organised differently. For example:
d1 $ slow 4 $ striate 3 $ sound "numbers:0 numbers:1 numbers:2 numbers:3"
This plays the loop the given number of times, but triggering progressive portions of each sample. So in this case it plays the loop three times, the first time playing the first third of each sample, then the second time playing the second third of each sample, and then finally the last third of each sample..
Compare this with chop:
d1 $ slow 4 $ chop 3 $ sound "numbers:0 numbers:1 numbers:2 numbers:3"
You can hear that the striate version 'interlaces' the cut up bits of samples together, whereas the chop version plays the bits from each chopped up sample in turn. It might be worth listening to the samples without granulation, in case that helps understand what’s happening in the above:
d1 $ slow 4 $ sound "numbers:0 numbers:1 numbers:2 numbers:3"


striateBy :: Pattern Int -> Pattern Double -> ControlPattern -> ControlPattern
striateBy is a variant of striate. with an extra parameter, which specifies the length of each part. striate still scans across the sample over a single cycle, but if each bit is longer, it creates a sort of stuttering effect. For example the following will cut the bev sample into 32 parts, but each will be 1/16th of a sample long:
d1 $ slow 32 $ striate' 32 (1/16) $ sound "bev"
Note that striate uses the begin and end parameters internally. This means that if you’re using striate or striateBy you probably shouldn’t also specify begin or end.


stut :: Pattern Integer -> Pattern Double -> Pattern Rational -> ControlPattern -> ControlPattern
stut applies a type of delay to a pattern. It has three parameters, which could be called depth, feedback and time. Depth is an integer and the others floating point. This adds a bit of echo:
d1 $ stut 4 0.5 0.1 $ sound "bd sn"
The above results in 4 repeats (the original plus 3 echoes), each echo 50% (that's the 0.5) quieter than the last, separated by 1/10th (that's the 0.1) of a cycle.
It is possible to reverse the echo:
d1 $ stut 4 0.5 (-0.1) $ sound "bd sn"


stutWith :: Pattern Int -> Pattern Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
stutWith (formerly known as stut') is similar to stut described above, but instead of just decreasing volume to produce echoes, stutWith applies a function each step and overlays the result delayed by the given time.
d1 $ stutWith 3 (1/3) (# vowel "{a e i o u}%2") $ sound "bd sn"
In this case there are two overlays delayed by 1/3 of a cycle, where each has the vowel filter applied.
d1 $ stutWith 4 (1/6) (|* speed "1.5") $ sound "arpy arpy:2"
In the above, three versions are put on top, with each step getting higher in pitch as |* speed "1.5" is successively applied.


vowel :: Pattern String -> ControlPattern
vowel turns a string pattern into a control pattern that creates a formant filter to produce vowel sounds on samples.
Use values a, e, i, o, and u to add the effect. The rest ~ character creates no effect:
d1 $ s "jvbass*4" # vowel "[a e ~ i o u]/8"


waveloss :: Pattern Double -> ControlPattern
waveloss divides an audio stream into tiny segments, using the signal's zero-crossings as segment boundaries, and discards a defined fraction of them. Values range from 0 to 100.
d1 $ s "drum*8" # waveloss "20 66.6 80 10"


hurry :: Pattern Time -> Pattern a -> Pattern a
hurry is similiar to fast, in that it speeds up a pattern, but it also increases the speed control by the same factor, so if you're triggering samples, the sound gets higher in pitch. For example:
d1 $ every 2 (hurry 2) $ sound "bd sn:2 ~ cp"


interlace :: ControlPattern -> ControlPattern -> ControlPattern
interlace shifts between two patterns, by using SuperDirt's shape distortion control pattern. For example:
d1 $ interlace (sound  "bd sn kurt") (every 3 rev $ sound "bd sn:2")
Over 16 cycles, the first pattern will slowly rise and fall in waveshaping distortion (and as a result, in volume), and the second pattern will do the opposite, falling and then rising. The resulting effect sounds like the patterns are taking turns coming 'to the front' of the audio scene.
The above is the equivalent of the following:
d1 $ sound "bd sn kurt" # shape (slow 16 $ sine * 0.9)
d2 $ every 3 rev $ sound "bd sn:2" # shape (8 <~ (slow 16 $ sine * 0.9))
I.e. the distortion will follow a sinewave from 0 to 0.9, over 16 cycles. The second pattern will do the same, but offset by 8 cycles.


loopAt :: Pattern Time -> ControlPattern -> ControlPattern
loopAt makes sample fit the given number of cycles. Internally, it works by setting the unit control to "c", changing the playback speed of the sample with the speed parameter, and setting the density of the pattern to match.
d1 $ loopAt 4 $ sound "breaks125"
It’s a good idea to use this in conjuction with chop, so the break is chopped into pieces and you don’t have to wait for the whole sample to start/stop.
d1 $ loopAt 4 $ chop 32 $ sound "breaks125"
Like all tidal functions, you can mess about with this considerably. The below example shows how you can supply a pattern of cycle counts to loopAt:
d1 $ juxBy 0.6 (|* speed "2") $ loopAt "<4 6 2 3>" $ chop 12 $ sound "fm:14"


randslice :: Pattern Int -> ControlPattern -> ControlPattern
randslice chops the sample into the given number of pieces and then plays back a random one each cycle:
d1 $ randslice 32 $ sound "bev"
Use fast to get more than one per cycle;
d1 $ fast 4 $ randslice 32 $ sound "bev"


smash :: Pattern Int -> [Pattern Time] -> ControlPattern -> ControlPattern
smash is a combination of spread and striate - it cuts the samples into the given number of bits, and then cuts between playing the loop at different speeds according to the values in the list.
So this:
d1 $ smash 3 [2,3,4] $ sound "ho ho:2 ho:3 hc"
Is a bit like this:
d1 $ slow "<2 3 4>" $ striate 3 $ sound "ho ho:2 ho:3 hc"


weave :: Time -> ControlPattern -> [ControlPattern] -> ControlPattern
weave applies one control pattern to a list of other control patterns, with a successive time offset. For example:
d1 $ weave 16 (pan sine)
  [sound "bd sn cp",
   sound "casio casio:1",
   sound "[jvbass*2 jvbass:2]/2",
   sound "hc*4"
  ]
In the above, the pan sine control pattern is slowed down by the given number of cycles, in particular 16, and applied to all of the given sound patterns. What makes this interesting is that the pan control pattern is successively offset for each of the given sound patterns; because the pan is closed down by 16 cycles, and there are four patterns, they are 'spread out', i.e. with a gap of four cycles. For this reason, the four patterns seem to chase after each other around the stereo field. Try listening on headphones to hear this more clearly.
You can even have it the other way round, and have the effect parameters chasing after each other around a sound parameter, like this:
d1 $ weave 16 (sound "arpy" >| n (run 8))
  [vowel "a e i",
   vowel "i [i o] o u",
   vowel "[e o]/3 [i o u]/2",
   speed "1 2 3"
  ]


weaveWith :: Time -> Pattern a -> [Pattern a -> Pattern a] -> Pattern a
weaveWith (formerly known as weave') is similar to the above, but weaves with a list of functions, rather than a list of controls. For example:
d1 $ weaveWith 3 (sound "bd [sn drum:2*2] bd*2 [sn drum:1]")
  [fast 2, 
   (# speed "0.5"),
   chop 16
  ]



## UI

arpeggiate :: Pattern a -> Pattern a
arpg :: Pattern a -> Pattern a
The arpeggiate (alias arpg) function spreads chords of note numbers over time.
For example, using the 1.0 chord name notation & older list notation:
d1 $ n (arpg "'major7 [0,4,7,11]") # sound "superpiano"


arp :: Pattern String -> Pattern a -> Pattern a
The arp function takes an additional pattern of arpeggiate modes.
For example, using the 1.0 chord name notation (root note / chord type / additional notes above the chord):
d1 $ n (arp "<up down diverge>" "<a'm9'8 e'7sus4'8>") # sound "superpiano"
The different arpeggiate modes are:
up down updown downup up&down down&up converge diverge disconverge pinkyup pinkyupdown thumbup thumbupdown
The different chords available are:
major maj minor min major7 maj7 dom7 minor7 min7 aug dim dim7 one 1 five 5 plus sharp5 msharp5 sus2 sus4 six 6 m6 sevenSus2 7sus2 sevenSus4 7sus4 sevenFlat5 7f5 m7flat5 m7f5 sevenSharp5 7s5 m7sharp5 m7s5 nine m9 m7sharp9 m7s9 maj9 nineSus4 ninesus4 9sus4 sixby9 6by9 m6by9 sevenFlat9 7f9 m7flat9 m7f9 sevenFlat10 7f10 nineSharp5 9s5 m9sharp5 m9s5 sevenSharp5flat9 7s5f9 m7sharp5flat9 eleven 11 m11 maj11 elevenSharp 11s m11sharp m11s thirteen 13 m13


brak :: Pattern a -> Pattern a
brak makes a pattern sound a bit like a breakbeat. It does this by every other cycle, squashing the pattern to fit half a cycle, and offsetting it by a quarter of a cycle.
d1 $ brak $ sound "[feel feel:3, hc:3 hc:2 hc:4 ho:1]"


choose :: [a] -> Pattern a
The choose function emits a stream of randomly choosen values from the given list, as a continuous pattern.
d1 $ sound "drum ~ drum drum" # n (choose [0,2,3])
As with all continuous patterns, you have to be careful to give them structure; in this case choose gives you an infinitely detailed stream of random choices.


chooseBy :: Pattern Double -> [a] -> Pattern a
The chooseBy function is like choose but instead of selecting elements of the list randomly, it uses the given pattern to select elements.
chooseBy "0 0.25 0.5" ["a","b","c","d"]
will result in the pattern "a b c"


chunk :: Int -> (Pattern b -> Pattern b) -> Pattern b -> Pattern b
chunk divides a pattern into a given number of parts, then cycles through those parts in turn, applying the given function to each part in turn (one part per cycle).
d1 $ chunk 4 (# speed 2) $ sound "bd hh sn cp"
The below highlights in bold which part of the above pattern has the (# speed 2) function applied to it over four cycles:
bd hh sn cp
bd hh sn cp
bd hh sn cp
bd hh sn cp
Another example:
d1 $ chunk 4 (hurry 2) $ sound "bd sn:2 [~ bd] sn:2"


chunk' :: Int -> (Pattern b -> Pattern b) -> Pattern b -> Pattern b
chunk' does the same as chunk but cycles through the parts in the reverse direction.


cycleChoose :: [a] -> Pattern a
similar to choose, but only picks once per cycle
d1 $ sound "drum ~ drum drum" # n (cycleChoose [0,2,3])


degrade :: Pattern a -> Pattern a
degrade randomly removes events from a pattern, 50% of the time. Example usage:
d1 $ slow 2 $ degrade $ sound "[[[feel:5*8,feel*3] feel:3*8], feel*4]"
   # accelerate "-6"
   # speed "2"


degradeBy :: Double -> Pattern a -> Pattern a
Similarly to degrade, degradeBy allows you to control the percentage of events that are removed. For example, to remove events 90% of the time:
d1 $ slow 2 $ degradeBy 0.9 $ sound "[[[feel:5*8,feel*3] feel:3*8], feel*4]"
   # accelerate "-6"
   # speed "2"


discretise :: Pattern Time -> Pattern a -> Pattern a
euclid :: Pattern Int -> Pattern Int -> Pattern a -> Pattern a
euclid creates a Euclidean rhythmic structure. It produces the same output as the Euclidean pattern string.
d1 $ euclid 3 8 $ sound "cp"
... is the same as ...
d1 $ sound "cp(3,8)"
euclid accepts two parameters that can be patterns:
d1 $ euclid "<3 5>" "[8 16]/4" $ s "bd"


fastspread :: (a -> t -> Pattern b) -> [a] -> t -> Pattern b
fastspread works the same as spread, but the result is squashed into a single cycle. If you gave four values to spread, then the result would seem to speed up by a factor of four. Compare these two:
d1 $ spread ($) [gap 4, striate 4] $ sound "ho ho:2 ho:3 hc"
d1 $ fastspread ($) [gap 4, striate 4] $ sound "ho ho:2 ho:3 hc"


fit :: Int -> [a] -> Pattern Int -> Pattern a
The fit function takes a pattern of integer numbers, which are used to select values from the given list. What makes this a bit strange is that only a given number of values are selected each cycle. For example:
d1 $ sound (fit 3 ["bd", "sn", "arpy", "arpy:1", "casio"] "0 [~ 1] 2 1")
The above fits samples into the pattern by number, i.e. for the first cycle this will be "bd", "sn" and "arpy", giving the result "bd [~ sn] arpy sn" (note that we start counting at zero, so that 0 picks the first value). For the following cycle, the same is done again, but offset by the number given in the first parameter. In the above case it's 3, which is effectively added to all the numbers, giving "3 [~ 4] 5 4", giving giving the pattern "arpy:1 [~ casio] bd casio" (note that the list wraps round here, so 5 goes back to choose the first element in the list). The next cycle, 6 is added to all the numbers, then 9, and so on.


fit' :: Time -> Int -> Pattern Int -> Pattern Int -> Pattern a -> Pattern a
fit' is a generalization of fit, where the list is instead constructed by using another integer pattern to slice up a given pattern. The first argument is the number of cycles of that latter pattern to use when slicing. It’s easier to understand this with a few examples:
d1 $ sound (fit' 1 2 "0 1" "1 0" "bd sn")
So what does this do? The first 1 just tells it to slice up a single cycle of "bd sn". The 2 tells it to select two values each cycle, just like the first argument to fit. The next pattern "0 1" is the “from” pattern which tells it how to slice, which in this case means "0" maps to "bd", and "1" maps to "sn". The next pattern "1 0" is the “to” pattern, which tells it how to rearrange those slices. So the final result is the pattern "sn bd".
A more useful example might be something like
d1 $ fit' 1 4 (run 4) "[0 3*2 2 1 0 3*2 2 [1*8 ~]]/2" $ chop 4 $ (sound "breaks152" # unit "c")
which uses chop to break a single sample into individual pieces, which fit' then puts into a list (using the run 4 pattern) and reassembles according to the complicated integer pattern.


fix :: (ControlPattern -> ControlPattern) -> ControlPattern -> ControlPattern -> ControlPattern
The fix function applies another function to matching events in a pattern of controls.
d1 $ slow 2 $ fix (# crush 3) (n "[1,4]") $ n "0 1 2 3 4 5 6" # sound "arpy"
The above only adds the crush control when the n control is set to either 1 or 4.
You can be quite specific, for example fix (hurry 2) (s "drum" # n "1") to apply the function hurry 2 to sample 1 of the drum sampleset, and leave the rest as they are.


ghost :: Pattern ControlMap -> Pattern ControlMap
ghost adds quieter, pitch-shifted, copies of an event after the event, emulating ghost notes that are common in drumming patterns.
d1 $ stack [ ghost $ sound "~ sn", sound "bd*2 [~ bd]" ]
The example above creates a kick snare pattern with ghost notes applied to the snare hit.


ifp :: (Int -> Bool) -> (Pattern a -> Pattern a) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
ifp decides whether to apply one or another function depending on the result of a test function, which is passed the current cycle as a number. For example:
d1 $ ifp ((== 0).(flip mod 2))
  (striate 4)
  (# coarse "24 48") $
  sound "hh hc"
This will apply striate 4 for every even cycle, and # coarse "24 48" for every odd one.
Detail: The test function does not rely on anything tidal-specific, it uses plain Haskell functionality for operating on numbers. That is, it calculates the modulo of 2 of the current cycle which is either 0 (for even cycles) or 1. It then compares this value against 0 and returns the result, which is either True or False. This is what the first part of ifp's type signature signifies (Int -> Bool), a function that takes a whole number and returns either True or False.


inside :: Pattern Time -> (Pattern a -> Pattern b) -> Pattern a -> Pattern b
inside carries out an operation 'inside' a cycle.
For example, while rev "0 1 2 3 4 5 6 7" is the same as "7 6 5 4 3 2 1 0", inside 2 rev "0 1 2 3 4 5 6 7" gives "3 2 1 0 7 6 5 4".
What this function is really doing is 'slowing down' the pattern by a given factor, applying the given function to it, and then 'speeding it up' by the same factor. In other words, this:
inside 2 rev "0 1 2 3 4 5 6 7"
Is doing this:
fast 2 $ rev $ slow 2 "0 1 2 3 4 5 6 7"
.. so rather than whole cycles, each half of a cycle is reversed.


irand :: Num a => Int -> Pattern a
A function from an integer (giving the maximum) to a stream of (pseudo-)random integer numbers. See[ the rand page for more details.
d1 $ sound "drum*8" # n (irand 8)


iter :: Pattern Int -> Pattern a -> Pattern a
iter divides a pattern into a given number of subdivisions, plays the subdivisions in order, but increments the starting subdivision each cycle. The pattern wraps to the first subdivision after the last subdivision is played.
d1 $ iter 4 $ sound "bd hh sn cp"
This will produce the following over four cycles:
bd hh sn cp
hh sn cp bd
sn cp bd hh
cp bd hh sn


iter' :: Pattern Int -> Pattern a -> Pattern a
iter' does the same as iter but in the other direction. So this:
d1 $ iter' 4 $ sound "bd hh sn cp"
Produces this pattern:
bd hh sn cp
cp bd hh sn
sn cp bd hh
hh sn cp bd


jux :: (ControlPattern -> ControlPattern) -> ControlPattern -> ControlPattern
The jux function creates strange stereo effects, by applying a function to a pattern, but only in the right-hand channel. For example, the following reverses the pattern on the righthand side:
d1 $ slow 32 $ jux (rev) $ striate' 32 (1/16) $ sound "bev"
When passing functions to functions like jux and every, it’s possible to chain multiple transforms together with ., for example this both reverses and halves the playback speed of the pattern in the righthand channel:
d1 $ slow 32 $ jux ((# speed "0.5") . rev) $ striate' 32 (1/16) $ sound "bev"


juxBy :: Pattern Double -> (ControlPattern -> ControlPattern) -> ControlPattern -> ControlPattern
With jux, the original and effected versions of the pattern are panned hard left and right (i.e., panned at 0 and 1). This can be a bit much, especially when listening on headphones. The variant juxBy has an additional parameter, which brings the channel closer to the centre. For example:
d1 $ juxBy 0.5 (fast 2) $ sound "bd sn:1"
In the above, the two versions of the pattern would be panned at 0.25 and 0.75, rather than 0 and 1.


layer :: [a -> Pattern b] -> a -> Pattern b
The layer function allows you to layer up multiple functions on one pattern.
For example the following will play two versions of the pattern at the same time, one reversed and one at twice the speed.
d1 $ layer [rev, fast 2] $ sound "arpy [~ arpy:4]"
If you want to include the original version of the pattern in the layering, use the id function:
d1 $ layer [id, rev, fast 2] $ sound "arpy [~ arpy:4]"


lindenmayer :: Num b => Int -> String -> String -> [b]
lindenmayer takes an integer b, a Lindenmayer system rule set and an initiating string as input in order to generate an L-system tree string of b iterations. It can be used in conjunction with a step function to convert the generated string into a playable pattern.
For example:
d1 $ slow 16 $ sound $ step' ["feel:0", "sn:1", "bd:0"]
(take 512 $ lindenmayer 5 "0:1~~~,1:0~~~2~~~~~0~~~2~,2:2~1~,~:~~1~"
"0")
... generates an L-system with initiating string "0" and maps it onto a list of samples.
Complex L-system trees with many rules and iterations can sometimes result in unwieldy strings. Using take n to only use the first n elements of the string, along with a slow function, can make the generated values more manageable.


linger :: Pattern Time -> Pattern a -> Pattern a
linger is similar to trunc, in that it truncates a pattern so that only the first fraction of the pattern is played. However unlike trunk, linger repeats that part to fill the remainder of the cycle.
The following example plays only the first three quarters of the pattern. For example this repeats the first quarter, so you only hear a single repeating note:
d1 $ linger 0.25 $ n "0 2 [3 4] 2" # sound "arpy"
or slightly more interesting, applied only every fourth cycle:
d1 $ every 4 (linger 0.25) $ n "0 2 [3 4] 2" # sound "arpy"
or to a chopped-up sample:
d1 $ every 2 (linger 0.25) $ loopAt 2 $ chop 8 $ sound "breaks125"
You can also pattern the first parameter, for example to cycle through three values, one per cycle:
d1 $ linger "<0.75 0.25 1>" $ sound "bd sn:2 [mt rs] hc"


mask :: Pattern Bool -> Pattern a -> Pattern a
mask takes a boolean (aka binary) pattern and 'masks' another pattern with it. That is, events are only carried over if they match within a 'true' event in the binary pattern.
For example consider this kind of messy rhythm without any rests.
d1 $ sound (cat ["sn*8", "[cp*4 bd*4, hc*5]"]) # n (run 8)
If we apply a mask to it
d1 $ mask "t t t ~ t t ~ t"
  $ s (cat ["sn*8", "[cp*4 bd*4, bass*5]"])
  # n (run 8)
Due to the use of cat here, the same mask is first applied to "sn*8" and in the next cycle to "[cp4 bd4, hc*5]".
You could achieve the same effect by adding rests within the cat patterns, but mask allows you to do this more easily. It kind of keeps the rhythmic structure and you can change the used samples independently, e.g.
d1 $ mask "1 ~ 1 ~ 1 1 ~ 1"
  $ s (cat ["can*8", "[cp*4 sn*4, jvbass*16]"])
  # n (run 8)


off :: Pattern Time -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
off is similar to superimpose, in that it applies a function to a pattern, and layers up the results on top of the original pattern. The difference is that off takes an extra pattern being a time (in cycles) to shift the transformed version of the pattern by.
The following plays a pattern on top of itself, but offset by an eighth of a cycle, with a distorting bitcrush effect applied.
d1 $ off 0.125 (# crush 2) $ sound "bd [~ sn:2] mt lt*2"
The following makes arpeggios by adding offset patterns that are shifted up the scale:
d1 $ slow 2 $ 
  n (off 0.25 (+12) $ off 0.125 (+7) $ slow 2 "c(3,8) a(3,8,2) f(3,8) e(3,8,4)") 
  # sound "superpiano"


outside :: Pattern Time -> (Pattern a -> Pattern b) -> Pattern a -> Pattern b
outside is the inverse of the inside function. outside applies its function outside the cycle. Say you have a pattern that takes 4 cycles to repeat and apply the `rev` function.
d1 $ rev $ cat [s "bd bd sn",s "sn sn bd", s"lt lt sd", s "sd sd bd"]
The above generates: d1 $ rev $ cat [s "sn bd bd",s "bd sn sn", s "sd lt lt", s "bd sd sd"]
However if you apply `outside`: d1 $ outside 4 (rev) $ cat [s "bd bd sn",s "sn sn bd", s"lt lt sd", s "sd sd bd"]
The result is : d1 $ rev $ cat [s "bd sd sd", s "sd lt lt", s "sn sn bd", s "bd bd sn"]
Notice the whole idea has been reversed.
What this function is really doing is 'speeding up' the pattern by a given factor, applying the given function to it, and then 'slowing it down' by the same factor. In other words, this:
d1 $ slow 4 $ rev $ fast 4 $ cat [s "bd bd sn",s "sn sn bd", s"lt lt sd", s "sd sd bd"]
This compresses the idea into a single cycle before `rev` operates and then slows it back to the original speed.


palindrome :: Pattern a -> Pattern a
The palindrome function applies rev to a pattern every other cycle, so that the pattern alternates between forwards and backwards.
d1 $ palindrome $ sound "arpy:0 arpy:1 arpy:2 arpy:3"
... is the same as this:
d1 $ slow 2 $ sound "arpy:0 arpy:1 arpy:2 arpy:3 arpy:3 arpy:2 arpy:1 arpy:0"
... and indeed this:
d1 $ every 2 rev $ sound "arpy:0 arpy:1 arpy:2 arpy:3"


perlin :: Pattern Double
perlin produces 1D Perlin (smooth) noise. It works like rand but smoothly moves between random values each cycle.
For example, you can smoothly and randomly change speed:
d1 $ sound "bd*32" # speed (perlin + 0.5)
The perlin function produces a new random value to move to every cycle. If you want a new random value to be generated more or less frequently, you can use fast or slow, respectively:
d1 $ sound "bd*32" # speed (fast 4 $ perlin + 0.5)
d1 $ sound "bd*32" # speed (slow 4 $ perlin + 0.5)


perlinWith :: Pattern Double -> Pattern Double
perlinWith allows you to specify a pattern as input to generate random values instead of using the default cycle count:
d1 $ s "arpy*32" # cutoff (perlinWith (saw * 4) * 2000)


perlin2 :: Pattern Double -> Pattern Double
perlin2 creates 2D noise by allowing you to specify a custom pattern as a second dimension (cycle number remains as the first dimension):
d1 $ s "bd*32" # speed (perlin2 (sine*4) + 1)


perlin2With :: Pattern Double -> Pattern Double -> Pattern Double
perlin2With is the same as perlinWith except allows you to provide two functions for 2D noise:
d1
 $ s "[arpy*32]"
 # lpf (range 60 5000 $ perlin2With (cosine*2) (sine*2))
 # lpq 0.3


ply :: Pattern Int -> Pattern a -> Pattern a
The ply function repeats each event the given number of times. For example
ply 3 $ s "bd ~ sn cp"
... is equivalent to ...
s "[bd bd bd] ~ [sn sn sn] [cp cp cp]"
The first parameter may be given as a pattern, so that:
ply "2 3" $ s "bd ~ sn cp"
... is equivalent to ...
s "[bd bd] ~ [sn sn sn] [cp cp cp]"
Here is an example of it being used conditionally:
d1 $ every 3 (ply 4) $ s "bd ~ sn cp"


rand :: Fractional a => Pattern a
An infinitely detailed stream of (pseudo-)random numbers.
d1 $ sound "bd*8" # pan rand


randcat :: [Pattern a] -> Pattern a
randcat is similar to cat, but rather than playing the given patterns in order, it picks them at random. For example:
d1 $ randcat [sound "bd*2 sn", sound "jvbass*3", sound "drum*2", sound "ht mt"]


range :: Num a => Pattern a -> Pattern a -> Pattern a -> Pattern a
range will take a pattern which goes from 0 to 1 (such as sine), and scale it to a different range - between the first and second arguments. In the below example, range 1 1.5 shifts the range of sine from 0 - 1 to 1 - 1.5.
d1 $ jux (iter 4) $ sound "arpy arpy:2*2"
  |+| speed (slow 4 $ range 1 1.5 sine)
The above is equivalent to the following:
d1 $ jux (iter 4) $ sound "arpy arpy:2*2"
  |+| speed (slow 4 $ sine * 0.5 + 1)


rangex :: (Floating b, Functor f) => b -> b -> f b -> f b
rangex is an exponential version of range described above, good to use for frequencies. For example, range 20 2000 "0.5" will give 1010 - halfway between 20 and 2000. But rangex 20 2000 0.5 will give 200 - halfway between on a logarithmic scale. This usually sounds better if you’re using the numbers as pitch frequencies. Since rangex uses logarithms, don’t try to scale things to zero or less!


rot :: Ord a => Pattern Int -> Pattern a -> Pattern a
The rot function 'rotates' the values in a pattern, while preserving its structure. For example in the following, each value will shift to its neighbour's position one step to the left, so that b takes the place of a, a of c, and c of b:
rot 1 "a ~ b c"
The result is equivalent of
"b ~ c a"
The first parameter is the number of steps, and may be given as a pattern, for example:
d1 $ rot "<0 0 1 3>" $ n "0 ~ 1 2 0 2 ~ 3*2" # sound "drum"
The above will not rotate the pattern for the first two cycles, will rotate it by one the third cycle, and by three the fourth cycle.


scramble :: Int -> Pattern a -> Pattern a
scramble takes a number and a pattern as input, divides the pattern into the given number of parts, and returns a new pattern by randomly selecting from the parts. This could also be called "sampling with replacement". For example:
d1 $ sound $ scramble 3 "bd sn hh"
... will sometimes play "sn bd hh" or "hh sn bd", but can also play "bd sn bd" or "hh hh hh", because it can make any random combination of the three parts.


segment :: Pattern Time -> Pattern a -> Pattern a
segment 'samples' the pattern at a rate of n events per cycle. Useful for turning a continuous pattern into a discrete one.
In this example, the pattern originates from the shape of a sine wave, a continuous pattern. Without segment the samples will get triggered at an undefined frequency which may be very high.
d1 $ n (slow 2 $ segment 16 $ range 0 32 $ sine) # sound "amencutup"


seqP :: [(Time, Time, Pattern a)] -> Pattern a
seqP allows you sequence patterns, with start and end times. The code below contains three separate patterns in a “stack”, but each has different start times (zero cycles, eight cycles, and sixteen cycles, respectively). In the example, all patterns stop after 12 cycles:
d1 $ seqP [ 
  (0, 12, sound "bd bd*2"), 
  (4, 12, sound "hh*2 [sn cp] cp future*4"), 
  (8, 12, sound (samples "arpy*8" (run 16)))
]
If you run the above, you probably won’t hear anything. This is because cycles start ticking up as soon as you start Tidal, and you have probably already gone part cycle 12.
You can reset the cycle clock back to zero by running setcps (-1) followed by setcps 1 (nb: at the time of writing, this doesn't yet work in version 1.0.0 of tidal, but you can instead run resetCycles), or whatever tempo you want to restart at. Alternatively, you can shift time for the seqP pattern back to zero like this:
d1 $ (pure now) ~> seqP [ 
  (0, 12, sound "bd bd*2"), 
  (4, 12, sound "hh*2 [sn cp] cp future*4"), 
  (8, 12, sound (samples "arpy*8" (run 16)))
]
Currently, In tidal 1.0.0, pure now is not yet implemented. So the following can be used instead:
do
{
  resetCycles;
  d1 $ seqP [ 
    (0, 12, sound "bd bd*2"), 
    (4, 12, sound "hh*2 [sn cp] cp future*4"), 
    (8, 12, sound (samples "arpy*8" (run 16)))
  ]
}


seqPLoop :: [(Time, Time, Pattern a)] -> Pattern a
A third option is to use seqPLoop instead, which will keep looping the sequence when it gets to the end:
d1 $ (pure now) ~> seqPLoop [ 
  (0, 12, sound "bd bd*2"), 
  (4, 12, sound "hh*2 [sn cp] cp future*4"), 
  (8, 12, sound (samples "arpy*8" (run 16)))
]
Currently, In tidal 1.0.0, pure now is not yet implemented. So the following can be used instead:
do
{
  resetCycles;
  d1 $ seqPLoop [
  (0, 12, sound "bd bd*2"), 
  (4, 12, sound "hh*2 [sn cp] cp future*4"), 
  (8, 12, sound (samples "arpy*8" (run 16)))
]
For building and testing out longer sequences, it may be helpful to skip cycles with rotL.


sew :: Pattern Bool -> Pattern a -> Pattern a -> Pattern a
sew Uses a pattern of boolean (true or false) values to switch between two other patterns. For example the following will play the first pattern for the first half of a cycle, and the second pattern for the other half.
d1 $ sound (sew "t f" "bd*8" "cp*8")
The above combines two patterns of strings, and passes the result to the sound function. It's also possible to sew together two control patterns, for example:
d1 $ sew "t <f t> <f [f t] t>" (n "0 .. 15" # s "future") (s "cp:3*16" # speed saw + 1.2)
You can also use Euclidean rhythm syntax in the boolean sequence:
d1 $ sew "t(11,16)" (n "0 .. 15" # s "future") (s "cp:3*16" # speed sine + 1.5)


shuffle :: Int -> Pattern a -> Pattern a
shuffle takes a number and a pattern as input, divides the pattern into the given number of parts, and returns a new pattern as a random permutation of the parts, picking one of each per cycle. This could also be called "sampling without replacement". For example:
d1 $ sound $ shuffle 3 "bd sn hh"
... will sometimes play "sn bd hh" or "hh sn bd", but will never play "bd sn bd" or "hh hh hh", because that isn't a permutation of the three parts.


slowstripe :: Pattern Int -> Pattern a -> Pattern a
The slowstripe function is the same as stripe but the result is also slowed down by n time (where n is the first parameter of the function. This means that the mean average duration of the stripes is exactly one cycle, and every nth stripe starts on a cycle boundary (in indian classical terms, the sam).
d1 $ slowstripe 3 $ sound "bd sd ~ [mt ht]"
d2 $ sound "cp"


someCycles :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a
someCycles is similar to sometimes, but instead of applying the given function to random events, it applies it to random cycles. For example the following will either distort all of the events in a cycle, or none of them:
d1 $ someCycles (# crush 2) $ n "0 1 [~ 2] 3" # sound "arpy"


someCyclesBy :: Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
As with sometimesBy, if you want to be specific, you can use someCyclesBy and a number. For example
someCyclesBy 0.93 (# speed 2)
will apply the speed control on average 93 cycles out of a hundred.


always :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a  (100%)
almostAlways :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a (90%)
often :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a (75%)
sometimes :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a (50%)
rarely :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a (25%)
almostNever :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a (10%)
never :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a (0%)
sometimes is function, that applies another function to a pattern, around 50% of the time, at random. It takes two inputs, the function to be applied, and the pattern you are applying it to.
For example to distort half the events in a pattern:
d1 $ sometimes (# crush 2) $ n "0 1 [~ 2] 3" # sound "arpy"


sometimesBy :: Pattern Double -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
If you want to be specific, you can use sometimesBy and a number, for example
sometimesBy 0.93 (# speed 2)
to apply the speed control on average 93 times out of a hundred.


spread :: (a -> t -> Pattern b) -> [a] -> t -> Pattern b
spreadf :: [a -> Pattern b] -> a -> Pattern b
spreadr :: (t -> t1 -> Pattern b) -> [t] -> t1 -> Pattern b
The spread function allows you to take a pattern transformation which takes a parameter, such as `slow`, and provide several parameters which are switched between. In other words it 'spreads' a function across several values.
Taking a simple high hat loop as an example:
d1 $ sound "ho ho:2 ho:3 hc"
We can speed it up by different amounts, such as by 2x:
d1 $ fast 2 $ sound "ho ho:2 ho:3 hc"
Or by 3x:
d1 $ fast 3 $ sound "ho ho:2 ho:3 hc"
But if we use spread, we can make a pattern which alternates between the two speeds:
d1 $ spread fast[2,3] $ sound "ho ho:2 ho:3 hc"
Note that many functions now allow pattern input. This is equivalent to the above
d1 $ fast "<2 3>" $ sound "ho ho:2 ho:3 hc"
Note that if you pass ($) as the function to spread values over, you can put different functions as the list of values. For example:
d1 $ spread ($) [density 2, rev, slow 2, striate 3, (# speed "0.8")] $ sound "[bd*2 [~ bd]] [sn future]*2 cp jvbass*4"
Above, the pattern will have these transforms applied to it, one at a time, per cycle:
cycle 1: density 2 - pattern will increase in speed
cycle 2: rev - pattern will be reversed
cycle 3: slow 2 - pattern will decrease in speed
cycle 4: striate 3 - pattern will be granualized
cycle 5: (# speed "0.8") - pattern samples will be played back more slowly
After (# speed "0.8"), the transforms will repeat and start at density 2 again.


spreadChoose :: (t -> t1 -> Pattern b) -> [t] -> t1 -> Pattern b
spreadChoose (alias spreadr) works the same as spread, but the values are selected at random, one cycle at a time. For example:
d1 $ spreadChoose ($) [gap 4, striate 4] $ sound "ho ho:2 ho:3 hc"


stripe :: Pattern Int -> Pattern a -> Pattern a
The stripe function repeats a pattern at random speeds. The first parameter gives the number of cycles to operate over, for example stripe 2 will repeat a pattern twice, over two cycles. Each cycle will be played at a random speed, but in such a way that the total duration will be the same.
For example in the following example, the start of every third repetition of the d1 pattern will match with the clap on the d2 pattern.
d1 $ stripe 3 $ sound "bd sd ~ [mt ht]"
d2 $ sound "cp"


slowstripe :: Pattern Int -> Pattern a -> Pattern a
The slowstripe function is the same as stripe but the result is also slowed down by n time (where n is the first parameter of the function. This means that the mean average duration of the stripes is exactly one cycle, and every nth stripe starts on a cycle boundary (in indian classical terms, the sam).
usage:
d1 $ slowstripe 3 $ sound "bd sd ~ [mt ht]"
d2 $ sound "cp"


struct :: Pattern Bool -> Pattern a -> Pattern a
struct places a rhythmic 'boolean' structure on the pattern you give it.
For example:
d1 $ struct ("t ~ t*2 ~") $ sound "cp"
... is the same as ...
d1 $ sound "cp ~ cp*2 ~"
The structure comes from a boolean pattern, i.e. a binary one containing true or false values. Above we only used true values, denoted by t. It's also possible to include false values with f, which struct will simply treat as silience. For example, this would have the same outcome as the above:
d1 $ struct ("t f t*2 f") $ sound "cp"
These true/false binary patterns become useful when you conditionally manipulate them, for example 'inverting' the values using every and inv:
d1 $ struct (every 3 inv "t f t*2 f") $ sound "cp"
In the above, the boolean values will be 'inverted' every third cycle, so that the structure comes from the fs rather than t.
Note that euclidean patterns also create true/false values, for example:
d1 $ struct (every 3 inv "t(3,8)") $ sound "cp"
In the above, the euclidean pattern creates "t f t f t f f t" which gets inverted to "f t f t f t t f" every third cycle.
Note that if you prefer you can use 1 and 0 instead of t and f. See also mask.


superimpose :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a
superimpose plays a modified version of a pattern 'on top of' the original pattern, resulting in the modified and original version of the patterns being played at the same time. For example this:
d1 $ superimpose (fast 2) $ sound "bd sn [cp ht] hh"
...is the same as this:
d1 $ stack [sound "bd sn [cp ht] hh", fast 2 $ sound "bd sn [cp ht] hh"]


swing :: Pattern Time -> Pattern a -> Pattern a
swing is an alias for swingBy (1/3)


swingBy :: Pattern Time -> Pattern Time -> Pattern a -> Pattern a
The function swingBy x n breaks each cycle into n slices, and then delays events in the second half of each slice by the amount x, which is relative to the size of the (half) slice. So if x is 0 it does nothing, 0.5 delays for half the note duration, and 1 will wrap around to doing nothing again. The end result is a shuffle or swing-like rhythm. For example:
d1 $ swingBy (1/3) 4 $ sound "hh*8"
will delay every other "hh" 1/3 of the way to the next "hh".


toScale :: Num a => [a] -> Pattern Int -> Pattern a
toScale allows you to quickly apply a scale without naming it. For example:
d1 $ n (toScale [0,2,3,5,7,8,10] "0 1 2 3 4 5 6 7") # sound "superpiano"


trunc :: Pattern Time -> Pattern a -> Pattern a
trunc truncates a pattern so that only a fraction of the pattern is played. The following example plays only the first three quarters of the pattern:
d1 $ trunc 0.75 $ sound "bd sn*2 cp hh*4 arpy bd*2 cp bd*2"
You can also pattern the first parameter, for example to cycle through three values, one per cycle:
d1 $ trunc "<0.75 0.25 1>" $ sound "bd sn:2 [mt rs] hc"
See also linger


ur :: Time -> Pattern String -> [(String, Pattern a)] -> [(String, Pattern a -> Pattern a)] -> Pattern a
The ur function is designed for longer form composition, by allowing you to create 'patterns of patterns' in a repeating loop. It takes three parameters -- how long the loop will take, a pattern giving the structure of the composition, a lookup table for named patterns to feed into that structure, and a second lookup table for named transformations/fx.
Lets say you had three patterns (called 'a', 'b' and 'c'), and that you wanted to play them four cycles each, over twelve cycles in total. Here is one way to do it:
let pats =
      [
        ("a", stack [n "c4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",
                     n "[c3,g4,c4]" # s "superpiano"# gain "0.7"
                    ]
        ),
        ("b", stack [n "d4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",
                     n "[d3,a4,d4]" # s "superpiano"# gain "0.7"
                    ]
        ),
        ("c", stack [n "f4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",
                     n "[f4,c5,f4]" # s "superpiano"# gain "0.7"
                    ]
        )
      ]
in
d1 $ ur 12 "a b c" pats []
In ur 12 "a b c" pats [], the 12 is the duration of the loop (in cycles), the "a b c" is the structure of named patterns, and pats is the lookup table, defined above. So the "a b c" pattern happens over the 12 cycles, with the a, b and c standing in for each of the three patterns given in the lookup table. Because there are three events in this pattern, and it happens over 12 cycles. then each event is four cycles long.
In the above, the fourth parameter is given as an empty list, but that is where you can put another lookup table, of functions rather than patterns this time. Here's an example:
let pats =
      [
        ("a", stack [n "c4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",
                     n "[c3,g4,c4]" # s "superpiano"# gain "0.7"
                    ]
        ),
        ("b", stack [n "d4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",
                     n "[d3,a4,d4]" # s "superpiano"# gain "0.7"
                    ]
        ),
        ("c", stack [n "f4 c5 g4 f4 f5 g4 e5 g4" # s "superpiano" # gain "0.7",
                     n "[f4,c5,f4]" # s "superpiano"# gain "0.7"
                    ]
        )
      ]
    fx = [("reverse", (# (room 0.8 # sz 0.99 # orbit 1))),
          ("faster", fast 2)
         ]
in
d1 $ ur 12 "a b:reverb c:faster" pats fx
In the above, b has the function applied that's named as reverb, while c is made to go faster.
It's also possible to schedule multiple patterns at once, like in the following:
let pats = [("drums", s "drum clap*2"),
            ("melody", s "arpy:2 arpy:3 arpy:5"),
            ("craziness", s "clap:4*8" # speed ( sine + 0.5))
           ]
    fx = [("higher", (# speed 2))]
in
d1 $ ur 8 "[drums, melody] [drums,craziness,melody] melody:higher" pats fx


wchoose :: [(a, Double)] -> Pattern a
wchoose is similar to choose, but allows you to 'weight' the choices, so some are more likely to be chosen than others. The following is similar to the previous example, but the 2 is twice as likely to be chosen than the 0 or 3.
d1 $ sound "drum ~ drum drum" # n (wchoose [(0,0.25),(2,0.5),(3,0.25)])
Note: prior to version 1.0.0 of tidal, the weights had to add up to 1, but this is no longer the case.


wchooseBy :: Pattern Double -> [(a,Double)] -> Pattern a
The wchooseBy function is like wchoose but instead of selecting elements of the list randomly, it uses the given pattern to select elements.


wedge :: Time -> Pattern a -> Pattern a -> Pattern a
wedge combines two patterns by squashing them into a single cycle. It takes a ratio as the first argument. The ratio determines what percentage of the pattern cycle is taken up by the first pattern. The second pattern fills in the remainder of the pattern cycle. For example:
d1 $ wedge (1/4) (sound "bd*2 arpy*3 cp sn*2") (sound "odx [feel future]*2 hh hh")


whenmod :: Int -> Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
whenmod has a similar form and behavior to every, but requires an additional number. It applies the function to the pattern, when the remainder of the current loop number divided by the first parameter, is greater or equal than the second parameter.
For example the following makes every other block of four loops twice as fast:
d1 $ whenmod 8 4 (fast 2) (sound "bd sn kurt")


within :: Arc -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
Use within to apply a function to only a part of a pattern. within takes two arguments: a start time and an end time, specified as floats between 0 and 1, which are applied to the relevant pattern. Note that the second argument must be greater than the first for the function to have any effect.
For example, to apply fast 2 to only the first half of a pattern:
d1 $ within (0, 0.5) (fast 2) $ sound "bd*2 sn lt mt hh hh hh hh"
Or, to apply (# speed "0.5") to only the last quarter of a pattern:
d1 $ within (0.75, 1) (# speed "0.5") $ sound "bd*2 sn lt mt hh hh hh hh"




== VARIOUS 


binary :: Pattern Int -> Pattern Bool
binary allows you to express a boolean pattern as a decimal number.
For example `163` in binary is `10100011`, and so these are equivalent:
d1 $ struct (binary 163) $ sound "clap:4"
d1 $ struct "t f t f f f t t" $ sound "clap:4"
That number can be patterned:
d1 $ struct (binary ("163 63")) $ sound "clap:4"


binaryN :: Int -> Pattern Int -> Pattern Bool
binaryN lets you specify a number of bits for the pattern. For example 55532 gives the boolean pattern 1101100011101100:
d1 $ struct (binaryN 16 55532) $ sound "bd"


ascii :: Pattern String -> Pattern Bool
Turns characters into 8-bit binary patterns, using their ASCII encoding. E.g. the letter 'a' give the binary pattern 01100001.
d1 $ struct (ascii "<[a b] [c d] [e f] [g h]>") $ sound "bd" # speed 2


bite :: Int -> Pattern Int -> Pattern a -> Pattern a
The bite function allows you to slice each cycle into a given number of equal sized bits, and then pattern those bits by number. It's similar to slice, but is for slicing up patterns, rather than samples.
The following slices the pattern into four bits, and then plays those bits in turn.
d1 $ bite 4 "0 1 2 3" $ n "0 .. 7" # sound "arpy"
Of course that doesn't actually change anything, but then you can reorder those bits:
d1 $ bite 4 "2 0 1 3" $ n "0 .. 7" # sound "arpy"
The slices bits of pattern will be squeezed or contracted to fit:
d1 $ bite 4 "2 [0 3] 1*4 1" $ n "0 .. 7" # sound "arpy"


chew :: Int -> Pattern Int -> Pattern a -> Pattern a
chew works the same as bite, but speeds up/slows down playback of sounds as well as squeezing / contracting the slices of pattern.
Compare these:
d1 $ bite 4 "0 1*2 2*2 [~ 3]" $ n "0 .. 7" # sound "drum"
d1 $ chew 4 "0 1*2 2*2 [~ 3]" $ n "0 .. 7" # sound "drum"


deconstruct :: Int -> Pattern String -> String
The deconstruct function displays the given number of steps within a pattern of strings. It's useful for visualising simple patterns, for example for seeing what a euclidean pattern is doing.
deconstruct 8 "[bd(3,8), sn(5,8,2)]"
returns:
"[bd, sn] sn ~ [bd, sn] sn ~ [bd, sn] ~"


scale :: Num a => Pattern String -> Pattern Int -> Pattern a
The scale function interprets a pattern of note numbers into a particular named scale.
d1 $ jux rev $ chunk 4 (fast 2 . (|- n 12)) $ off 0.25 (|+ 7) $ struct (iter 4 "t(5,8)")
  $ n (scale "ritusen" "0 .. 7") # sound "superpiano"
Please note that prior to Tidal version 1.0.0, scale had a very different function as a range operator. Veteran users will need to switch to using range for this functionality.


scaleList :: String
The scaleList function outputs all the available scales, at the time of writing:
minPent majPent ritusen egyptian kumai hirajoshi iwato chinese indian pelog prometheus scriabin gong shang jiao zhi yu whole augmented augmented2 hexMajor7 hexDorian hexPhrygian hexSus hexMajor6 hexAeolian major ionian dorian phrygian lydian mixolydian aeolian minor locrian harmonicMinor harmonicMajor melodicMinor melodicMinorDesc melodicMajor bartok hindu todi purvi marva bhairav ahirbhairav superLocrian romanianMinor hungarianMinor neapolitanMinor enigmatic spanish leadingWhole lydianMinor neapolitanMajor locrianMajor diminished diminished2 chromatic


getScale :: Num a => [(String, [a])] -> Pattern String -> Pattern Int -> Pattern a
You can build your own `scale` function with additional scales if you wish, using getScale. For example:
let scale = getScale (scaleTable ++ [("techno", [0,2,3,5,7,8,10]),
                                     ("broken", [0,1,4,7,8,10])])
The above takes the standard scaleTable as a starting point, and adds two custom scales to it.
You'll be able to use the new function as normal:
d1 $ n (scale "techno" "0 1 2 3 4 5 6 7") # sound "superpiano"



markovPat :: Pattern Int -> Pattern Int -> [[Double]] -> Pattern Int
markovPat generates a one-cycle pattern of steps in a Markov chain with a transition matrix and an initial state. Each row of the transition matrix is automatically normalized.
markovPat 8 1 [[3,5,2], [4,4,2], [0,1,0]]
Generates a pattern of 8 steps, beginning at state #1, with three states (0, 1, or 2):
(0>⅛)|1
(⅛>¼)|2
(¼>⅜)|1
(⅜>½)|1
(½>⅝)|2
(⅝>¾)|1
(¾>⅞)|1
(⅞>1)|0
To use it in a Tidal pattern, you will need to map the resulting steps with something like fmap:
d1 $ s "bd*8" # speed (fmap ([1,2,3]!!) $ markovPat 8 1 [[3,5,2], [4,4,2], [0,1,0]])
d1 $ s "drum*8" # n (fmap ([0,3,5]!!) $ markovPat 8 1 [[3,5,2], [4,4,2], [0,1,0]])
d1 $ s (fmap (["bd", "cp", "arpy"]!!) $ markovPat 8 1 [[3,5,2], [4,4,2], [0,1,0]])


snowball :: Int -> (Pattern a -> Pattern a -> Pattern a) -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
The snowball function recursively combines a pattern with a modified version itself using a combination function over the given number of cycles. Each passing cycle is one level deeper in the recursion and is based of all the previous cycles.
It takes 3 arguments. First a number representing an iteration limit. Second, an operator to combine the patterns with. Third, a function to modify the patterns with.
d1 $ note (scale "minor" $ snowball 4 (+) (slow 2) $ (run 3)) #sound "gtr" #gain 0.9
For the first cycle, we hear the result of the `run` function. In the second cycle we hear the previous pattern added to a slowed version of itself. The third cycle we hear the result of cycle 2 added to a slowed version of itself. Same goes for the 4th cycle. The result is a rising wandering melody over four cycles. (note that it takes more than 4 cycles to repeat as the base pattern is slowed by 2 again and again until the iteration limit is reached.
This, as the name suggests, can quickly get out of hand.


soak :: Int -> (Pattern a -> Pattern a) -> Pattern a -> Pattern a
The soak function applies the given function over the given number of cycles. For example:
d1 $ soak 4 (* speed 1.5) $ sound "bd(3,8) sd:2"
For the first cycle, the function won't be applied at all, the second it'll be applied once, the third twice and fourth three times. The result is an increase of playback speed over four cycles.
The following creates a wandering melodic phrase that returns to the original after 4 cycles:
d1 $ (note $ scale "hexPhrygian" $ soak 4 ((0.25 <~).(+ irand(2))) "0 . 2 3 ~ . 0 1 . -1 -2") #s "gtr"
This example will build up a kick rush over 4 bars:
d1 $ soak 4 (iter 8. slow 2 .ply 3) $ euclid 3 5 $ sound "bd sn"


